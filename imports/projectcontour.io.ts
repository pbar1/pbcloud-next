// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ContourConfiguration is the schema for a Contour instance.
 *
 * @schema ContourConfiguration
 */
export class ContourConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContourConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ContourConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "ContourConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContourConfigurationProps): any {
    return {
      ...ContourConfiguration.GVK,
      ...toJson_ContourConfigurationProps(props),
    };
  }

  /**
   * Defines a "ContourConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContourConfigurationProps) {
    super(scope, id, {
      ...ContourConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContourConfiguration.GVK,
      ...toJson_ContourConfigurationProps(resolved),
    };
  }
}

/**
 * ContourConfiguration is the schema for a Contour instance.
 *
 * @schema ContourConfiguration
 */
export interface ContourConfigurationProps {
  /**
   * @schema ContourConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.
   *
   * @schema ContourConfiguration#spec
   */
  readonly spec: ContourConfigurationSpec;

}

/**
 * Converts an object of type 'ContourConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationProps(obj: ContourConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContourConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContourConfigurationSpec represents a configuration of a Contour controller. It contains most of all the options that can be customized, the other remaining options being command line flags.
 *
 * @schema ContourConfigurationSpec
 */
export interface ContourConfigurationSpec {
  /**
   * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
   *
   * @schema ContourConfigurationSpec#debug
   */
  readonly debug?: ContourConfigurationSpecDebug;

  /**
   * EnableExternalNameService allows processing of ExternalNameServices
   * Contour's default is false for security reasons.
   *
   * @schema ContourConfigurationSpec#enableExternalNameService
   */
  readonly enableExternalNameService?: boolean;

  /**
   * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
   *
   * @schema ContourConfigurationSpec#envoy
   */
  readonly envoy?: ContourConfigurationSpecEnvoy;

  /**
   * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
   *
   * @schema ContourConfigurationSpec#gateway
   */
  readonly gateway?: ContourConfigurationSpecGateway;

  /**
   * GlobalExternalAuthorization allows envoys external authorization filter to be enabled for all virtual hosts.
   *
   * @schema ContourConfigurationSpec#globalExtAuth
   */
  readonly globalExtAuth?: ContourConfigurationSpecGlobalExtAuth;

  /**
   * Health defines the endpoints Contour uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourConfigurationSpec#health
   */
  readonly health?: ContourConfigurationSpecHealth;

  /**
   * HTTPProxy defines parameters on HTTPProxy.
   *
   * @schema ContourConfigurationSpec#httpproxy
   */
  readonly httpproxy?: ContourConfigurationSpecHttpproxy;

  /**
   * Ingress contains parameters for ingress options.
   *
   * @schema ContourConfigurationSpec#ingress
   */
  readonly ingress?: ContourConfigurationSpecIngress;

  /**
   * Metrics defines the endpoint Contour uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourConfigurationSpec#metrics
   */
  readonly metrics?: ContourConfigurationSpecMetrics;

  /**
   * Policy specifies default policy applied if not overridden by the user
   *
   * @schema ContourConfigurationSpec#policy
   */
  readonly policy?: ContourConfigurationSpecPolicy;

  /**
   * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
   *
   * @schema ContourConfigurationSpec#rateLimitService
   */
  readonly rateLimitService?: ContourConfigurationSpecRateLimitService;

  /**
   * Tracing defines properties for exporting trace data to OpenTelemetry.
   *
   * @schema ContourConfigurationSpec#tracing
   */
  readonly tracing?: ContourConfigurationSpecTracing;

  /**
   * XDSServer contains parameters for the xDS server.
   *
   * @schema ContourConfigurationSpec#xdsServer
   */
  readonly xdsServer?: ContourConfigurationSpecXdsServer;

}

/**
 * Converts an object of type 'ContourConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpec(obj: ContourConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'debug': toJson_ContourConfigurationSpecDebug(obj.debug),
    'enableExternalNameService': obj.enableExternalNameService,
    'envoy': toJson_ContourConfigurationSpecEnvoy(obj.envoy),
    'gateway': toJson_ContourConfigurationSpecGateway(obj.gateway),
    'globalExtAuth': toJson_ContourConfigurationSpecGlobalExtAuth(obj.globalExtAuth),
    'health': toJson_ContourConfigurationSpecHealth(obj.health),
    'httpproxy': toJson_ContourConfigurationSpecHttpproxy(obj.httpproxy),
    'ingress': toJson_ContourConfigurationSpecIngress(obj.ingress),
    'metrics': toJson_ContourConfigurationSpecMetrics(obj.metrics),
    'policy': toJson_ContourConfigurationSpecPolicy(obj.policy),
    'rateLimitService': toJson_ContourConfigurationSpecRateLimitService(obj.rateLimitService),
    'tracing': toJson_ContourConfigurationSpecTracing(obj.tracing),
    'xdsServer': toJson_ContourConfigurationSpecXdsServer(obj.xdsServer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
 *
 * @schema ContourConfigurationSpecDebug
 */
export interface ContourConfigurationSpecDebug {
  /**
   * Defines the Contour debug address interface.
   * Contour's default is "127.0.0.1".
   *
   * @schema ContourConfigurationSpecDebug#address
   */
  readonly address?: string;

  /**
   * Defines the Contour debug address port.
   * Contour's default is 6060.
   *
   * @schema ContourConfigurationSpecDebug#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecDebug' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecDebug(obj: ContourConfigurationSpecDebug | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
 *
 * @schema ContourConfigurationSpecEnvoy
 */
export interface ContourConfigurationSpecEnvoy {
  /**
   * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
   *
   * @schema ContourConfigurationSpecEnvoy#clientCertificate
   */
  readonly clientCertificate?: ContourConfigurationSpecEnvoyClientCertificate;

  /**
   * Cluster holds various configurable Envoy cluster values that can be set in the config file.
   *
   * @schema ContourConfigurationSpecEnvoy#cluster
   */
  readonly cluster?: ContourConfigurationSpecEnvoyCluster;

  /**
   * DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form "HTTP/xx". Supported versions are "HTTP/1.1" and "HTTP/2".
   * Values: `HTTP/1.1`, `HTTP/2` (default: both).
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoy#defaultHTTPVersions
   */
  readonly defaultHttpVersions?: string[];

  /**
   * Health defines the endpoint Envoy uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourConfigurationSpecEnvoy#health
   */
  readonly health?: ContourConfigurationSpecEnvoyHealth;

  /**
   * Defines the HTTP Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
   *
   * @schema ContourConfigurationSpecEnvoy#http
   */
  readonly http?: ContourConfigurationSpecEnvoyHttp;

  /**
   * Defines the HTTPS Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
   *
   * @schema ContourConfigurationSpecEnvoy#https
   */
  readonly https?: ContourConfigurationSpecEnvoyHttps;

  /**
   * Listener hold various configurable Envoy listener values.
   *
   * @schema ContourConfigurationSpecEnvoy#listener
   */
  readonly listener?: ContourConfigurationSpecEnvoyListener;

  /**
   * Logging defines how Envoy's logs can be configured.
   *
   * @schema ContourConfigurationSpecEnvoy#logging
   */
  readonly logging?: ContourConfigurationSpecEnvoyLogging;

  /**
   * Metrics defines the endpoint Envoy uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourConfigurationSpecEnvoy#metrics
   */
  readonly metrics?: ContourConfigurationSpecEnvoyMetrics;

  /**
   * Network holds various configurable Envoy network values.
   *
   * @schema ContourConfigurationSpecEnvoy#network
   */
  readonly network?: ContourConfigurationSpecEnvoyNetwork;

  /**
   * Service holds Envoy service parameters for setting Ingress status.
   * Contour's default is { namespace: "projectcontour", name: "envoy" }.
   *
   * @schema ContourConfigurationSpecEnvoy#service
   */
  readonly service?: ContourConfigurationSpecEnvoyService;

  /**
   * Timeouts holds various configurable timeouts that can be set in the config file.
   *
   * @schema ContourConfigurationSpecEnvoy#timeouts
   */
  readonly timeouts?: ContourConfigurationSpecEnvoyTimeouts;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoy(obj: ContourConfigurationSpecEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ContourConfigurationSpecEnvoyClientCertificate(obj.clientCertificate),
    'cluster': toJson_ContourConfigurationSpecEnvoyCluster(obj.cluster),
    'defaultHTTPVersions': obj.defaultHttpVersions?.map(y => y),
    'health': toJson_ContourConfigurationSpecEnvoyHealth(obj.health),
    'http': toJson_ContourConfigurationSpecEnvoyHttp(obj.http),
    'https': toJson_ContourConfigurationSpecEnvoyHttps(obj.https),
    'listener': toJson_ContourConfigurationSpecEnvoyListener(obj.listener),
    'logging': toJson_ContourConfigurationSpecEnvoyLogging(obj.logging),
    'metrics': toJson_ContourConfigurationSpecEnvoyMetrics(obj.metrics),
    'network': toJson_ContourConfigurationSpecEnvoyNetwork(obj.network),
    'service': toJson_ContourConfigurationSpecEnvoyService(obj.service),
    'timeouts': toJson_ContourConfigurationSpecEnvoyTimeouts(obj.timeouts),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
 *
 * @schema ContourConfigurationSpecGateway
 */
export interface ContourConfigurationSpecGateway {
  /**
   * ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of "projectcontour.io/<namespace>/contour". If unset, the gatewayclass controller will not be started. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourConfigurationSpecGateway#controllerName
   */
  readonly controllerName?: string;

  /**
   * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourConfigurationSpecGateway#gatewayRef
   */
  readonly gatewayRef?: ContourConfigurationSpecGatewayGatewayRef;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGateway(obj: ContourConfigurationSpecGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controllerName': obj.controllerName,
    'gatewayRef': toJson_ContourConfigurationSpecGatewayGatewayRef(obj.gatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalExternalAuthorization allows envoys external authorization filter to be enabled for all virtual hosts.
 *
 * @schema ContourConfigurationSpecGlobalExtAuth
 */
export interface ContourConfigurationSpecGlobalExtAuth {
  /**
   * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
   *
   * @schema ContourConfigurationSpecGlobalExtAuth#authPolicy
   */
  readonly authPolicy?: ContourConfigurationSpecGlobalExtAuthAuthPolicy;

  /**
   * ExtensionServiceRef specifies the extension resource that will authorize client requests.
   *
   * @schema ContourConfigurationSpecGlobalExtAuth#extensionRef
   */
  readonly extensionRef?: ContourConfigurationSpecGlobalExtAuthExtensionRef;

  /**
   * If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.
   *
   * @schema ContourConfigurationSpecGlobalExtAuth#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". The string "infinity" is also a valid input and specifies no timeout.
   *
   * @schema ContourConfigurationSpecGlobalExtAuth#responseTimeout
   */
  readonly responseTimeout?: string;

  /**
   * WithRequestBody specifies configuration for sending the client request's body to authorization server.
   *
   * @schema ContourConfigurationSpecGlobalExtAuth#withRequestBody
   */
  readonly withRequestBody?: ContourConfigurationSpecGlobalExtAuthWithRequestBody;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGlobalExtAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGlobalExtAuth(obj: ContourConfigurationSpecGlobalExtAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_ContourConfigurationSpecGlobalExtAuthAuthPolicy(obj.authPolicy),
    'extensionRef': toJson_ContourConfigurationSpecGlobalExtAuthExtensionRef(obj.extensionRef),
    'failOpen': obj.failOpen,
    'responseTimeout': obj.responseTimeout,
    'withRequestBody': toJson_ContourConfigurationSpecGlobalExtAuthWithRequestBody(obj.withRequestBody),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoints Contour uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourConfigurationSpecHealth
 */
export interface ContourConfigurationSpecHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourConfigurationSpecHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourConfigurationSpecHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHealth(obj: ContourConfigurationSpecHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxy defines parameters on HTTPProxy.
 *
 * @schema ContourConfigurationSpecHttpproxy
 */
export interface ContourConfigurationSpecHttpproxy {
  /**
   * DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecHttpproxy#disablePermitInsecure
   */
  readonly disablePermitInsecure?: boolean;

  /**
   * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
   *
   * @schema ContourConfigurationSpecHttpproxy#fallbackCertificate
   */
  readonly fallbackCertificate?: ContourConfigurationSpecHttpproxyFallbackCertificate;

  /**
   * Restrict Contour to searching these namespaces for root ingress routes.
   *
   * @schema ContourConfigurationSpecHttpproxy#rootNamespaces
   */
  readonly rootNamespaces?: string[];

}

/**
 * Converts an object of type 'ContourConfigurationSpecHttpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHttpproxy(obj: ContourConfigurationSpecHttpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disablePermitInsecure': obj.disablePermitInsecure,
    'fallbackCertificate': toJson_ContourConfigurationSpecHttpproxyFallbackCertificate(obj.fallbackCertificate),
    'rootNamespaces': obj.rootNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress contains parameters for ingress options.
 *
 * @schema ContourConfigurationSpecIngress
 */
export interface ContourConfigurationSpecIngress {
  /**
   * Ingress Class Names Contour should use.
   *
   * @schema ContourConfigurationSpecIngress#classNames
   */
  readonly classNames?: string[];

  /**
   * Address to set in Ingress object status.
   *
   * @schema ContourConfigurationSpecIngress#statusAddress
   */
  readonly statusAddress?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecIngress(obj: ContourConfigurationSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classNames': obj.classNames?.map(y => y),
    'statusAddress': obj.statusAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Contour uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourConfigurationSpecMetrics
 */
export interface ContourConfigurationSpecMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourConfigurationSpecMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourConfigurationSpecMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourConfigurationSpecMetrics#tls
   */
  readonly tls?: ContourConfigurationSpecMetricsTls;

}

/**
 * Converts an object of type 'ContourConfigurationSpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecMetrics(obj: ContourConfigurationSpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy specifies default policy applied if not overridden by the user
 *
 * @schema ContourConfigurationSpecPolicy
 */
export interface ContourConfigurationSpecPolicy {
  /**
   * ApplyToIngress determines if the Policies will apply to ingress objects
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecPolicy#applyToIngress
   */
  readonly applyToIngress?: boolean;

  /**
   * RequestHeadersPolicy defines the request headers set/removed on all routes
   *
   * @schema ContourConfigurationSpecPolicy#requestHeaders
   */
  readonly requestHeaders?: ContourConfigurationSpecPolicyRequestHeaders;

  /**
   * ResponseHeadersPolicy defines the response headers set/removed on all routes
   *
   * @schema ContourConfigurationSpecPolicy#responseHeaders
   */
  readonly responseHeaders?: ContourConfigurationSpecPolicyResponseHeaders;

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicy(obj: ContourConfigurationSpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyToIngress': obj.applyToIngress,
    'requestHeaders': toJson_ContourConfigurationSpecPolicyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_ContourConfigurationSpecPolicyResponseHeaders(obj.responseHeaders),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
 *
 * @schema ContourConfigurationSpecRateLimitService
 */
export interface ContourConfigurationSpecRateLimitService {
  /**
   * Domain is passed to the Rate Limit Service.
   *
   * @schema ContourConfigurationSpecRateLimitService#domain
   */
  readonly domain?: string;

  /**
   * EnableResourceExhaustedCode enables translating error code 429 to grpc code RESOURCE_EXHAUSTED. When disabled it's translated to UNAVAILABLE
   *
   * @schema ContourConfigurationSpecRateLimitService#enableResourceExhaustedCode
   */
  readonly enableResourceExhaustedCode?: boolean;

  /**
   * EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request.
   * ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
   *
   * @schema ContourConfigurationSpecRateLimitService#enableXRateLimitHeaders
   */
  readonly enableXRateLimitHeaders?: boolean;

  /**
   * ExtensionService identifies the extension service defining the RLS.
   *
   * @schema ContourConfigurationSpecRateLimitService#extensionService
   */
  readonly extensionService: ContourConfigurationSpecRateLimitServiceExtensionService;

  /**
   * FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.
   *
   * @schema ContourConfigurationSpecRateLimitService#failOpen
   */
  readonly failOpen?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecRateLimitService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecRateLimitService(obj: ContourConfigurationSpecRateLimitService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enableResourceExhaustedCode': obj.enableResourceExhaustedCode,
    'enableXRateLimitHeaders': obj.enableXRateLimitHeaders,
    'extensionService': toJson_ContourConfigurationSpecRateLimitServiceExtensionService(obj.extensionService),
    'failOpen': obj.failOpen,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tracing defines properties for exporting trace data to OpenTelemetry.
 *
 * @schema ContourConfigurationSpecTracing
 */
export interface ContourConfigurationSpecTracing {
  /**
   * CustomTags defines a list of custom tags with unique tag name.
   *
   * @schema ContourConfigurationSpecTracing#customTags
   */
  readonly customTags?: ContourConfigurationSpecTracingCustomTags[];

  /**
   * ExtensionService identifies the extension service defining the otel-collector.
   *
   * @schema ContourConfigurationSpecTracing#extensionService
   */
  readonly extensionService: ContourConfigurationSpecTracingExtensionService;

  /**
   * IncludePodDetail defines a flag. If it is true, contour will add the pod name and namespace to the span of the trace. the default is true. Note: The Envoy pods MUST have the HOSTNAME and CONTOUR_NAMESPACE environment variables set for this to work properly.
   *
   * @schema ContourConfigurationSpecTracing#includePodDetail
   */
  readonly includePodDetail?: boolean;

  /**
   * MaxPathTagLength defines maximum length of the request path to extract and include in the HttpUrl tag. contour's default is 256.
   *
   * @schema ContourConfigurationSpecTracing#maxPathTagLength
   */
  readonly maxPathTagLength?: number;

  /**
   * OverallSampling defines the sampling rate of trace data. contour's default is 100.
   *
   * @schema ContourConfigurationSpecTracing#overallSampling
   */
  readonly overallSampling?: string;

  /**
   * ServiceName defines the name for the service. contour's default is contour.
   *
   * @schema ContourConfigurationSpecTracing#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecTracing(obj: ContourConfigurationSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': obj.customTags?.map(y => toJson_ContourConfigurationSpecTracingCustomTags(y)),
    'extensionService': toJson_ContourConfigurationSpecTracingExtensionService(obj.extensionService),
    'includePodDetail': obj.includePodDetail,
    'maxPathTagLength': obj.maxPathTagLength,
    'overallSampling': obj.overallSampling,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * XDSServer contains parameters for the xDS server.
 *
 * @schema ContourConfigurationSpecXdsServer
 */
export interface ContourConfigurationSpecXdsServer {
  /**
   * Defines the xDS gRPC API address which Contour will serve.
   * Contour's default is "0.0.0.0".
   *
   * @schema ContourConfigurationSpecXdsServer#address
   */
  readonly address?: string;

  /**
   * Defines the xDS gRPC API port which Contour will serve.
   * Contour's default is 8001.
   *
   * @schema ContourConfigurationSpecXdsServer#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details.
   * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
   *
   * @schema ContourConfigurationSpecXdsServer#tls
   */
  readonly tls?: ContourConfigurationSpecXdsServerTls;

  /**
   * Defines the XDSServer to use for `contour serve`.
   * Values: `contour` (default), `envoy`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecXdsServer#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecXdsServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecXdsServer(obj: ContourConfigurationSpecXdsServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecXdsServerTls(obj.tls),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
 *
 * @schema ContourConfigurationSpecEnvoyClientCertificate
 */
export interface ContourConfigurationSpecEnvoyClientCertificate {
  /**
   * @schema ContourConfigurationSpecEnvoyClientCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecEnvoyClientCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyClientCertificate(obj: ContourConfigurationSpecEnvoyClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cluster holds various configurable Envoy cluster values that can be set in the config file.
 *
 * @schema ContourConfigurationSpecEnvoyCluster
 */
export interface ContourConfigurationSpecEnvoyCluster {
  /**
   * DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families, and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for upstream connections. Refer to Happy Eyeballs Support for more information. Note: This only applies to externalName clusters.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
   * Values: `auto` (default), `v4`, `v6`, `all`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyCluster#dnsLookupFamily
   */
  readonly dnsLookupFamily?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyCluster(obj: ContourConfigurationSpecEnvoyCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsLookupFamily': obj.dnsLookupFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoint Envoy uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourConfigurationSpecEnvoyHealth
 */
export interface ContourConfigurationSpecEnvoyHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourConfigurationSpecEnvoyHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourConfigurationSpecEnvoyHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHealth(obj: ContourConfigurationSpecEnvoyHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTP Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
 *
 * @schema ContourConfigurationSpecEnvoyHttp
 */
export interface ContourConfigurationSpecEnvoyHttp {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourConfigurationSpecEnvoyHttp#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHttp(obj: ContourConfigurationSpecEnvoyHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTPS Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
 *
 * @schema ContourConfigurationSpecEnvoyHttps
 */
export interface ContourConfigurationSpecEnvoyHttps {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourConfigurationSpecEnvoyHttps#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyHttps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyHttps(obj: ContourConfigurationSpecEnvoyHttps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Listener hold various configurable Envoy listener values.
 *
 * @schema ContourConfigurationSpecEnvoyListener
 */
export interface ContourConfigurationSpecEnvoyListener {
  /**
   * ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.
   * Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyListener#connectionBalancer
   */
  readonly connectionBalancer?: string;

  /**
   * DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the "Content-Length" header if "Transfer-Encoding: chunked" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#disableAllowChunkedLength
   */
  readonly disableAllowChunkedLength?: boolean;

  /**
   * DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option which strips duplicate slashes from request URL paths.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#disableMergeSlashes
   */
  readonly disableMergeSlashes?: boolean;

  /**
   * Defines the action to be applied to the Server header on the response path. When configured as overwrite, overwrites any Server header with "envoy". When configured as append_if_absent, if a Server header is present, pass it through, otherwise set it to "envoy". When configured as pass_through, pass through the value of the Server header, and do not append a header if none is present.
   * Values: `overwrite` (default), `append_if_absent`, `pass_through`
   * Other values will produce an error. Contour's default is overwrite.
   *
   * @schema ContourConfigurationSpecEnvoyListener#serverHeaderTransformation
   */
  readonly serverHeaderTransformation?: string;

  /**
   * TLS holds various configurable Envoy TLS listener values.
   *
   * @schema ContourConfigurationSpecEnvoyListener#tls
   */
  readonly tls?: ContourConfigurationSpecEnvoyListenerTls;

  /**
   * Use PROXY protocol for all listeners.
   * Contour's default is false.
   *
   * @schema ContourConfigurationSpecEnvoyListener#useProxyProtocol
   */
  readonly useProxyProtocol?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyListener(obj: ContourConfigurationSpecEnvoyListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBalancer': obj.connectionBalancer,
    'disableAllowChunkedLength': obj.disableAllowChunkedLength,
    'disableMergeSlashes': obj.disableMergeSlashes,
    'serverHeaderTransformation': obj.serverHeaderTransformation,
    'tls': toJson_ContourConfigurationSpecEnvoyListenerTls(obj.tls),
    'useProxyProtocol': obj.useProxyProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging defines how Envoy's logs can be configured.
 *
 * @schema ContourConfigurationSpecEnvoyLogging
 */
export interface ContourConfigurationSpecEnvoyLogging {
  /**
   * AccessLogFormat sets the global access log format.
   * Values: `envoy` (default), `json`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogFormat
   */
  readonly accessLogFormat?: string;

  /**
   * AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogFormatString
   */
  readonly accessLogFormatString?: string;

  /**
   * AccessLogJSONFields sets the fields that JSON logging will output when AccessLogFormat is json.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogJSONFields
   */
  readonly accessLogJsonFields?: string[];

  /**
   * AccessLogLevel sets the verbosity level of the access log.
   * Values: `info` (default, meaning all requests are logged), `error` and `disabled`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyLogging#accessLogLevel
   */
  readonly accessLogLevel?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyLogging(obj: ContourConfigurationSpecEnvoyLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogFormat': obj.accessLogFormat,
    'accessLogFormatString': obj.accessLogFormatString,
    'accessLogJSONFields': obj.accessLogJsonFields?.map(y => y),
    'accessLogLevel': obj.accessLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Envoy uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourConfigurationSpecEnvoyMetrics
 */
export interface ContourConfigurationSpecEnvoyMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourConfigurationSpecEnvoyMetrics#tls
   */
  readonly tls?: ContourConfigurationSpecEnvoyMetricsTls;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyMetrics(obj: ContourConfigurationSpecEnvoyMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourConfigurationSpecEnvoyMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Network holds various configurable Envoy network values.
 *
 * @schema ContourConfigurationSpecEnvoyNetwork
 */
export interface ContourConfigurationSpecEnvoyNetwork {
  /**
   * Configure the port used to access the Envoy Admin interface. If configured to port "0" then the admin interface is disabled.
   * Contour's default is 9001.
   *
   * @schema ContourConfigurationSpecEnvoyNetwork#adminPort
   */
  readonly adminPort?: number;

  /**
   * XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address.
   * See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.
   * Contour's default is 0.
   *
   * @schema ContourConfigurationSpecEnvoyNetwork#numTrustedHops
   */
  readonly numTrustedHops?: number;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyNetwork(obj: ContourConfigurationSpecEnvoyNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminPort': obj.adminPort,
    'numTrustedHops': obj.numTrustedHops,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service holds Envoy service parameters for setting Ingress status.
 * Contour's default is { namespace: "projectcontour", name: "envoy" }.
 *
 * @schema ContourConfigurationSpecEnvoyService
 */
export interface ContourConfigurationSpecEnvoyService {
  /**
   * @schema ContourConfigurationSpecEnvoyService#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecEnvoyService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyService(obj: ContourConfigurationSpecEnvoyService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timeouts holds various configurable timeouts that can be set in the config file.
 *
 * @schema ContourConfigurationSpecEnvoyTimeouts
 */
export interface ContourConfigurationSpecEnvoyTimeouts {
  /**
   * ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service. If not set, a default value of 2 seconds will be used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#connectionShutdownGracePeriod
   */
  readonly connectionShutdownGracePeriod?: string;

  /**
   * DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection.
   * Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#delayedCloseTimeout
   */
  readonly delayedCloseTimeout?: string;

  /**
   * MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to "infinity" for no max duration.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#requestTimeout
   */
  readonly requestTimeout?: string;

  /**
   * StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.
   *
   * @schema ContourConfigurationSpecEnvoyTimeouts#streamIdleTimeout
   */
  readonly streamIdleTimeout?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyTimeouts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyTimeouts(obj: ContourConfigurationSpecEnvoyTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'connectionShutdownGracePeriod': obj.connectionShutdownGracePeriod,
    'delayedCloseTimeout': obj.delayedCloseTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'requestTimeout': obj.requestTimeout,
    'streamIdleTimeout': obj.streamIdleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
 *
 * @schema ContourConfigurationSpecGatewayGatewayRef
 */
export interface ContourConfigurationSpecGatewayGatewayRef {
  /**
   * @schema ContourConfigurationSpecGatewayGatewayRef#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecGatewayGatewayRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGatewayGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGatewayGatewayRef(obj: ContourConfigurationSpecGatewayGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
 *
 * @schema ContourConfigurationSpecGlobalExtAuthAuthPolicy
 */
export interface ContourConfigurationSpecGlobalExtAuthAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema ContourConfigurationSpecGlobalExtAuthAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema ContourConfigurationSpecGlobalExtAuthAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGlobalExtAuthAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGlobalExtAuthAuthPolicy(obj: ContourConfigurationSpecGlobalExtAuthAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceRef specifies the extension resource that will authorize client requests.
 *
 * @schema ContourConfigurationSpecGlobalExtAuthExtensionRef
 */
export interface ContourConfigurationSpecGlobalExtAuthExtensionRef {
  /**
   * API version of the referent. If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
   *
   * @schema ContourConfigurationSpecGlobalExtAuthExtensionRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ContourConfigurationSpecGlobalExtAuthExtensionRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ContourConfigurationSpecGlobalExtAuthExtensionRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGlobalExtAuthExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGlobalExtAuthExtensionRef(obj: ContourConfigurationSpecGlobalExtAuthExtensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WithRequestBody specifies configuration for sending the client request's body to authorization server.
 *
 * @schema ContourConfigurationSpecGlobalExtAuthWithRequestBody
 */
export interface ContourConfigurationSpecGlobalExtAuthWithRequestBody {
  /**
   * If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
   *
   * @schema ContourConfigurationSpecGlobalExtAuthWithRequestBody#allowPartialMessage
   */
  readonly allowPartialMessage?: boolean;

  /**
   * MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
   *
   * @schema ContourConfigurationSpecGlobalExtAuthWithRequestBody#maxRequestBytes
   */
  readonly maxRequestBytes?: number;

  /**
   * If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
   *
   * @schema ContourConfigurationSpecGlobalExtAuthWithRequestBody#packAsBytes
   */
  readonly packAsBytes?: boolean;

}

/**
 * Converts an object of type 'ContourConfigurationSpecGlobalExtAuthWithRequestBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecGlobalExtAuthWithRequestBody(obj: ContourConfigurationSpecGlobalExtAuthWithRequestBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPartialMessage': obj.allowPartialMessage,
    'maxRequestBytes': obj.maxRequestBytes,
    'packAsBytes': obj.packAsBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
 *
 * @schema ContourConfigurationSpecHttpproxyFallbackCertificate
 */
export interface ContourConfigurationSpecHttpproxyFallbackCertificate {
  /**
   * @schema ContourConfigurationSpecHttpproxyFallbackCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecHttpproxyFallbackCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecHttpproxyFallbackCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecHttpproxyFallbackCertificate(obj: ContourConfigurationSpecHttpproxyFallbackCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourConfigurationSpecMetricsTls
 */
export interface ContourConfigurationSpecMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecMetricsTls(obj: ContourConfigurationSpecMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeadersPolicy defines the request headers set/removed on all routes
 *
 * @schema ContourConfigurationSpecPolicyRequestHeaders
 */
export interface ContourConfigurationSpecPolicyRequestHeaders {
  /**
   * @schema ContourConfigurationSpecPolicyRequestHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourConfigurationSpecPolicyRequestHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicyRequestHeaders(obj: ContourConfigurationSpecPolicyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseHeadersPolicy defines the response headers set/removed on all routes
 *
 * @schema ContourConfigurationSpecPolicyResponseHeaders
 */
export interface ContourConfigurationSpecPolicyResponseHeaders {
  /**
   * @schema ContourConfigurationSpecPolicyResponseHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourConfigurationSpecPolicyResponseHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourConfigurationSpecPolicyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecPolicyResponseHeaders(obj: ContourConfigurationSpecPolicyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the RLS.
 *
 * @schema ContourConfigurationSpecRateLimitServiceExtensionService
 */
export interface ContourConfigurationSpecRateLimitServiceExtensionService {
  /**
   * @schema ContourConfigurationSpecRateLimitServiceExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecRateLimitServiceExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecRateLimitServiceExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecRateLimitServiceExtensionService(obj: ContourConfigurationSpecRateLimitServiceExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomTag defines custom tags with unique tag name to create tags for the active span.
 *
 * @schema ContourConfigurationSpecTracingCustomTags
 */
export interface ContourConfigurationSpecTracingCustomTags {
  /**
   * Literal is a static custom tag value. Precisely one of Literal, RequestHeaderName must be set.
   *
   * @schema ContourConfigurationSpecTracingCustomTags#literal
   */
  readonly literal?: string;

  /**
   * RequestHeaderName indicates which request header the label value is obtained from. Precisely one of Literal, RequestHeaderName must be set.
   *
   * @schema ContourConfigurationSpecTracingCustomTags#requestHeaderName
   */
  readonly requestHeaderName?: string;

  /**
   * TagName is the unique name of the custom tag.
   *
   * @schema ContourConfigurationSpecTracingCustomTags#tagName
   */
  readonly tagName: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecTracingCustomTags(obj: ContourConfigurationSpecTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'requestHeaderName': obj.requestHeaderName,
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the otel-collector.
 *
 * @schema ContourConfigurationSpecTracingExtensionService
 */
export interface ContourConfigurationSpecTracingExtensionService {
  /**
   * @schema ContourConfigurationSpecTracingExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourConfigurationSpecTracingExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecTracingExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecTracingExtensionService(obj: ContourConfigurationSpecTracingExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details.
 * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
 *
 * @schema ContourConfigurationSpecXdsServerTls
 */
export interface ContourConfigurationSpecXdsServerTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#certFile
   */
  readonly certFile?: string;

  /**
   * Allow serving the xDS gRPC API without TLS.
   *
   * @schema ContourConfigurationSpecXdsServerTls#insecure
   */
  readonly insecure?: boolean;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecXdsServerTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecXdsServerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecXdsServerTls(obj: ContourConfigurationSpecXdsServerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'insecure': obj.insecure,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds various configurable Envoy TLS listener values.
 *
 * @schema ContourConfigurationSpecEnvoyListenerTls
 */
export interface ContourConfigurationSpecEnvoyListenerTls {
  /**
   * CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use.
   * This field is optional; when it is undefined, a Contour-managed ciphersuite list will be used, which may be updated to keep it secure.
   * Contour's default list is: - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]" - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]" - "ECDHE-ECDSA-AES256-GCM-SHA384" - "ECDHE-RSA-AES256-GCM-SHA384"
   * Ciphers provided are validated against the following list: - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]" - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]" - "ECDHE-ECDSA-AES128-GCM-SHA256" - "ECDHE-RSA-AES128-GCM-SHA256" - "ECDHE-ECDSA-AES128-SHA" - "ECDHE-RSA-AES128-SHA" - "AES128-GCM-SHA256" - "AES128-SHA" - "ECDHE-ECDSA-AES256-GCM-SHA384" - "ECDHE-RSA-AES256-GCM-SHA384" - "ECDHE-ECDSA-AES256-SHA" - "ECDHE-RSA-AES256-SHA" - "AES256-GCM-SHA384" - "AES256-SHA"
   * Contour recommends leaving this undefined unless you are sure you must.
   * See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
   *
   * @schema ContourConfigurationSpecEnvoyListenerTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate.
   * Values: `1.2` (default), `1.3`.
   * Other values will produce an error.
   *
   * @schema ContourConfigurationSpecEnvoyListenerTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyListenerTls(obj: ContourConfigurationSpecEnvoyListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'minimumProtocolVersion': obj.minimumProtocolVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourConfigurationSpecEnvoyMetricsTls
 */
export interface ContourConfigurationSpecEnvoyMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourConfigurationSpecEnvoyMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourConfigurationSpecEnvoyMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourConfigurationSpecEnvoyMetricsTls(obj: ContourConfigurationSpecEnvoyMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ContourDeployment is the schema for a Contour Deployment.
 *
 * @schema ContourDeployment
 */
export class ContourDeployment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ContourDeployment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ContourDeployment',
  }

  /**
   * Renders a Kubernetes manifest for "ContourDeployment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ContourDeploymentProps = {}): any {
    return {
      ...ContourDeployment.GVK,
      ...toJson_ContourDeploymentProps(props),
    };
  }

  /**
   * Defines a "ContourDeployment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ContourDeploymentProps = {}) {
    super(scope, id, {
      ...ContourDeployment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ContourDeployment.GVK,
      ...toJson_ContourDeploymentProps(resolved),
    };
  }
}

/**
 * ContourDeployment is the schema for a Contour Deployment.
 *
 * @schema ContourDeployment
 */
export interface ContourDeploymentProps {
  /**
   * @schema ContourDeployment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ContourDeploymentSpec specifies options for how a Contour instance should be provisioned.
   *
   * @schema ContourDeployment#spec
   */
  readonly spec?: ContourDeploymentSpec;

}

/**
 * Converts an object of type 'ContourDeploymentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentProps(obj: ContourDeploymentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContourDeploymentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContourDeploymentSpec specifies options for how a Contour instance should be provisioned.
 *
 * @schema ContourDeploymentSpec
 */
export interface ContourDeploymentSpec {
  /**
   * Contour specifies deployment-time settings for the Contour part of the installation, i.e. the xDS server/control plane and associated resources, including things like replica count for the Deployment, and node placement constraints for the pods.
   *
   * @schema ContourDeploymentSpec#contour
   */
  readonly contour?: ContourDeploymentSpecContour;

  /**
   * Envoy specifies deployment-time settings for the Envoy part of the installation, i.e. the xDS client/data plane and associated resources, including things like the workload type to use (DaemonSet or Deployment), node placement constraints for the pods, and various options for the Envoy service.
   *
   * @schema ContourDeploymentSpec#envoy
   */
  readonly envoy?: ContourDeploymentSpecEnvoy;

  /**
   * ResourceLabels is a set of labels to add to the provisioned Contour resources.
   *
   * @schema ContourDeploymentSpec#resourceLabels
   */
  readonly resourceLabels?: { [key: string]: string };

  /**
   * RuntimeSettings is a ContourConfiguration spec to be used when provisioning a Contour instance that will influence aspects of the Contour instance's runtime behavior.
   *
   * @schema ContourDeploymentSpec#runtimeSettings
   */
  readonly runtimeSettings?: ContourDeploymentSpecRuntimeSettings;

}

/**
 * Converts an object of type 'ContourDeploymentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpec(obj: ContourDeploymentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contour': toJson_ContourDeploymentSpecContour(obj.contour),
    'envoy': toJson_ContourDeploymentSpecEnvoy(obj.envoy),
    'resourceLabels': ((obj.resourceLabels) === undefined) ? undefined : (Object.entries(obj.resourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'runtimeSettings': toJson_ContourDeploymentSpecRuntimeSettings(obj.runtimeSettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Contour specifies deployment-time settings for the Contour part of the installation, i.e. the xDS server/control plane and associated resources, including things like replica count for the Deployment, and node placement constraints for the pods.
 *
 * @schema ContourDeploymentSpecContour
 */
export interface ContourDeploymentSpecContour {
  /**
   * Deployment describes the settings for running contour as a `Deployment`.
   *
   * @schema ContourDeploymentSpecContour#deployment
   */
  readonly deployment?: ContourDeploymentSpecContourDeployment;

  /**
   * KubernetesLogLevel Enable Kubernetes client debug logging with log level. If unset, defaults to 0.
   *
   * @schema ContourDeploymentSpecContour#kubernetesLogLevel
   */
  readonly kubernetesLogLevel?: number;

  /**
   * LogLevel sets the log level for Contour Allowed values are "info", "debug".
   *
   * @schema ContourDeploymentSpecContour#logLevel
   */
  readonly logLevel?: string;

  /**
   * NodePlacement describes node scheduling configuration of Contour pods.
   *
   * @schema ContourDeploymentSpecContour#nodePlacement
   */
  readonly nodePlacement?: ContourDeploymentSpecContourNodePlacement;

  /**
   * Deprecated: Use `DeploymentSettings.Replicas` instead.
   * Replicas is the desired number of Contour replicas. If if unset, defaults to 2.
   * if both `DeploymentSettings.Replicas` and this one is set, use `DeploymentSettings.Replicas`.
   *
   * @schema ContourDeploymentSpecContour#replicas
   */
  readonly replicas?: number;

  /**
   * Compute Resources required by contour container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecContour#resources
   */
  readonly resources?: ContourDeploymentSpecContourResources;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContour' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContour(obj: ContourDeploymentSpecContour | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_ContourDeploymentSpecContourDeployment(obj.deployment),
    'kubernetesLogLevel': obj.kubernetesLogLevel,
    'logLevel': obj.logLevel,
    'nodePlacement': toJson_ContourDeploymentSpecContourNodePlacement(obj.nodePlacement),
    'replicas': obj.replicas,
    'resources': toJson_ContourDeploymentSpecContourResources(obj.resources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy specifies deployment-time settings for the Envoy part of the installation, i.e. the xDS client/data plane and associated resources, including things like the workload type to use (DaemonSet or Deployment), node placement constraints for the pods, and various options for the Envoy service.
 *
 * @schema ContourDeploymentSpecEnvoy
 */
export interface ContourDeploymentSpecEnvoy {
  /**
   * DaemonSet describes the settings for running envoy as a `DaemonSet`. if `WorkloadType` is `Deployment`,it's must be nil
   *
   * @schema ContourDeploymentSpecEnvoy#daemonSet
   */
  readonly daemonSet?: ContourDeploymentSpecEnvoyDaemonSet;

  /**
   * Deployment describes the settings for running envoy as a `Deployment`. if `WorkloadType` is `DaemonSet`,it's must be nil
   *
   * @schema ContourDeploymentSpecEnvoy#deployment
   */
  readonly deployment?: ContourDeploymentSpecEnvoyDeployment;

  /**
   * ExtraVolumeMounts holds the extra volume mounts to add (normally used with extraVolumes).
   *
   * @schema ContourDeploymentSpecEnvoy#extraVolumeMounts
   */
  readonly extraVolumeMounts?: ContourDeploymentSpecEnvoyExtraVolumeMounts[];

  /**
   * ExtraVolumes holds the extra volumes to add.
   *
   * @schema ContourDeploymentSpecEnvoy#extraVolumes
   */
  readonly extraVolumes?: ContourDeploymentSpecEnvoyExtraVolumes[];

  /**
   * LogLevel sets the log level for Envoy. Allowed values are "trace", "debug", "info", "warn", "error", "critical", "off".
   *
   * @schema ContourDeploymentSpecEnvoy#logLevel
   */
  readonly logLevel?: string;

  /**
   * NetworkPublishing defines how to expose Envoy to a network.
   *
   * @schema ContourDeploymentSpecEnvoy#networkPublishing
   */
  readonly networkPublishing?: ContourDeploymentSpecEnvoyNetworkPublishing;

  /**
   * NodePlacement describes node scheduling configuration of Envoy pods.
   *
   * @schema ContourDeploymentSpecEnvoy#nodePlacement
   */
  readonly nodePlacement?: ContourDeploymentSpecEnvoyNodePlacement;

  /**
   * PodAnnotations defines annotations to add to the Envoy pods.
   *
   * @schema ContourDeploymentSpecEnvoy#podAnnotations
   */
  readonly podAnnotations?: { [key: string]: string };

  /**
   * Deprecated: Use `DeploymentSettings.Replicas` instead.
   * Replicas is the desired number of Envoy replicas. If WorkloadType is not "Deployment", this field is ignored. Otherwise, if unset, defaults to 2.
   * if both `DeploymentSettings.Replicas` and this one is set, use `DeploymentSettings.Replicas`.
   *
   * @schema ContourDeploymentSpecEnvoy#replicas
   */
  readonly replicas?: number;

  /**
   * Compute Resources required by envoy container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecEnvoy#resources
   */
  readonly resources?: ContourDeploymentSpecEnvoyResources;

  /**
   * WorkloadType is the type of workload to install Envoy as. Choices are DaemonSet and Deployment. If unset, defaults to DaemonSet.
   *
   * @schema ContourDeploymentSpecEnvoy#workloadType
   */
  readonly workloadType?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoy(obj: ContourDeploymentSpecEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'daemonSet': toJson_ContourDeploymentSpecEnvoyDaemonSet(obj.daemonSet),
    'deployment': toJson_ContourDeploymentSpecEnvoyDeployment(obj.deployment),
    'extraVolumeMounts': obj.extraVolumeMounts?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumeMounts(y)),
    'extraVolumes': obj.extraVolumes?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumes(y)),
    'logLevel': obj.logLevel,
    'networkPublishing': toJson_ContourDeploymentSpecEnvoyNetworkPublishing(obj.networkPublishing),
    'nodePlacement': toJson_ContourDeploymentSpecEnvoyNodePlacement(obj.nodePlacement),
    'podAnnotations': ((obj.podAnnotations) === undefined) ? undefined : (Object.entries(obj.podAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'replicas': obj.replicas,
    'resources': toJson_ContourDeploymentSpecEnvoyResources(obj.resources),
    'workloadType': obj.workloadType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuntimeSettings is a ContourConfiguration spec to be used when provisioning a Contour instance that will influence aspects of the Contour instance's runtime behavior.
 *
 * @schema ContourDeploymentSpecRuntimeSettings
 */
export interface ContourDeploymentSpecRuntimeSettings {
  /**
   * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#debug
   */
  readonly debug?: ContourDeploymentSpecRuntimeSettingsDebug;

  /**
   * EnableExternalNameService allows processing of ExternalNameServices
   * Contour's default is false for security reasons.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#enableExternalNameService
   */
  readonly enableExternalNameService?: boolean;

  /**
   * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#envoy
   */
  readonly envoy?: ContourDeploymentSpecRuntimeSettingsEnvoy;

  /**
   * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#gateway
   */
  readonly gateway?: ContourDeploymentSpecRuntimeSettingsGateway;

  /**
   * GlobalExternalAuthorization allows envoys external authorization filter to be enabled for all virtual hosts.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#globalExtAuth
   */
  readonly globalExtAuth?: ContourDeploymentSpecRuntimeSettingsGlobalExtAuth;

  /**
   * Health defines the endpoints Contour uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#health
   */
  readonly health?: ContourDeploymentSpecRuntimeSettingsHealth;

  /**
   * HTTPProxy defines parameters on HTTPProxy.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#httpproxy
   */
  readonly httpproxy?: ContourDeploymentSpecRuntimeSettingsHttpproxy;

  /**
   * Ingress contains parameters for ingress options.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#ingress
   */
  readonly ingress?: ContourDeploymentSpecRuntimeSettingsIngress;

  /**
   * Metrics defines the endpoint Contour uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8000 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#metrics
   */
  readonly metrics?: ContourDeploymentSpecRuntimeSettingsMetrics;

  /**
   * Policy specifies default policy applied if not overridden by the user
   *
   * @schema ContourDeploymentSpecRuntimeSettings#policy
   */
  readonly policy?: ContourDeploymentSpecRuntimeSettingsPolicy;

  /**
   * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#rateLimitService
   */
  readonly rateLimitService?: ContourDeploymentSpecRuntimeSettingsRateLimitService;

  /**
   * Tracing defines properties for exporting trace data to OpenTelemetry.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#tracing
   */
  readonly tracing?: ContourDeploymentSpecRuntimeSettingsTracing;

  /**
   * XDSServer contains parameters for the xDS server.
   *
   * @schema ContourDeploymentSpecRuntimeSettings#xdsServer
   */
  readonly xdsServer?: ContourDeploymentSpecRuntimeSettingsXdsServer;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettings(obj: ContourDeploymentSpecRuntimeSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'debug': toJson_ContourDeploymentSpecRuntimeSettingsDebug(obj.debug),
    'enableExternalNameService': obj.enableExternalNameService,
    'envoy': toJson_ContourDeploymentSpecRuntimeSettingsEnvoy(obj.envoy),
    'gateway': toJson_ContourDeploymentSpecRuntimeSettingsGateway(obj.gateway),
    'globalExtAuth': toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuth(obj.globalExtAuth),
    'health': toJson_ContourDeploymentSpecRuntimeSettingsHealth(obj.health),
    'httpproxy': toJson_ContourDeploymentSpecRuntimeSettingsHttpproxy(obj.httpproxy),
    'ingress': toJson_ContourDeploymentSpecRuntimeSettingsIngress(obj.ingress),
    'metrics': toJson_ContourDeploymentSpecRuntimeSettingsMetrics(obj.metrics),
    'policy': toJson_ContourDeploymentSpecRuntimeSettingsPolicy(obj.policy),
    'rateLimitService': toJson_ContourDeploymentSpecRuntimeSettingsRateLimitService(obj.rateLimitService),
    'tracing': toJson_ContourDeploymentSpecRuntimeSettingsTracing(obj.tracing),
    'xdsServer': toJson_ContourDeploymentSpecRuntimeSettingsXdsServer(obj.xdsServer),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deployment describes the settings for running contour as a `Deployment`.
 *
 * @schema ContourDeploymentSpecContourDeployment
 */
export interface ContourDeploymentSpecContourDeployment {
  /**
   * Replicas is the desired number of replicas.
   *
   * @schema ContourDeploymentSpecContourDeployment#replicas
   */
  readonly replicas?: number;

  /**
   * Strategy describes the deployment strategy to use to replace existing pods with new pods.
   *
   * @schema ContourDeploymentSpecContourDeployment#strategy
   */
  readonly strategy?: ContourDeploymentSpecContourDeploymentStrategy;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourDeployment(obj: ContourDeploymentSpecContourDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas,
    'strategy': toJson_ContourDeploymentSpecContourDeploymentStrategy(obj.strategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePlacement describes node scheduling configuration of Contour pods.
 *
 * @schema ContourDeploymentSpecContourNodePlacement
 */
export interface ContourDeploymentSpecContourNodePlacement {
  /**
   * NodeSelector is the simplest recommended form of node selection constraint and specifies a map of key-value pairs. For the pod to be eligible to run on a node, the node must have each of the indicated key-value pairs as labels (it can have additional labels as well).
   * If unset, the pod(s) will be scheduled to any available node.
   *
   * @schema ContourDeploymentSpecContourNodePlacement#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Tolerations work with taints to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints.
   * The default is an empty list.
   * See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/ for additional details.
   *
   * @schema ContourDeploymentSpecContourNodePlacement#tolerations
   */
  readonly tolerations?: ContourDeploymentSpecContourNodePlacementTolerations[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourNodePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourNodePlacement(obj: ContourDeploymentSpecContourNodePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ContourDeploymentSpecContourNodePlacementTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by contour container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ContourDeploymentSpecContourResources
 */
export interface ContourDeploymentSpecContourResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ContourDeploymentSpecContourResources#claims
   */
  readonly claims?: ContourDeploymentSpecContourResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecContourResources#limits
   */
  readonly limits?: { [key: string]: ContourDeploymentSpecContourResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecContourResources#requests
   */
  readonly requests?: { [key: string]: ContourDeploymentSpecContourResourcesRequests };

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourResources(obj: ContourDeploymentSpecContourResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ContourDeploymentSpecContourResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DaemonSet describes the settings for running envoy as a `DaemonSet`. if `WorkloadType` is `Deployment`,it's must be nil
 *
 * @schema ContourDeploymentSpecEnvoyDaemonSet
 */
export interface ContourDeploymentSpecEnvoyDaemonSet {
  /**
   * Strategy describes the deployment strategy to use to replace existing DaemonSet pods with new pods.
   *
   * @schema ContourDeploymentSpecEnvoyDaemonSet#updateStrategy
   */
  readonly updateStrategy?: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDaemonSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDaemonSet(obj: ContourDeploymentSpecEnvoyDaemonSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'updateStrategy': toJson_ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy(obj.updateStrategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deployment describes the settings for running envoy as a `Deployment`. if `WorkloadType` is `DaemonSet`,it's must be nil
 *
 * @schema ContourDeploymentSpecEnvoyDeployment
 */
export interface ContourDeploymentSpecEnvoyDeployment {
  /**
   * Replicas is the desired number of replicas.
   *
   * @schema ContourDeploymentSpecEnvoyDeployment#replicas
   */
  readonly replicas?: number;

  /**
   * Strategy describes the deployment strategy to use to replace existing pods with new pods.
   *
   * @schema ContourDeploymentSpecEnvoyDeployment#strategy
   */
  readonly strategy?: ContourDeploymentSpecEnvoyDeploymentStrategy;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDeployment(obj: ContourDeploymentSpecEnvoyDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replicas': obj.replicas,
    'strategy': toJson_ContourDeploymentSpecEnvoyDeploymentStrategy(obj.strategy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts
 */
export interface ContourDeploymentSpecEnvoyExtraVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema ContourDeploymentSpecEnvoyExtraVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumeMounts(obj: ContourDeploymentSpecEnvoyExtraVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumes
 */
export interface ContourDeploymentSpecEnvoyExtraVolumes {
  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#azureDisk
   */
  readonly azureDisk?: ContourDeploymentSpecEnvoyExtraVolumesAzureDisk;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#azureFile
   */
  readonly azureFile?: ContourDeploymentSpecEnvoyExtraVolumesAzureFile;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#cephfs
   */
  readonly cephfs?: ContourDeploymentSpecEnvoyExtraVolumesCephfs;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#cinder
   */
  readonly cinder?: ContourDeploymentSpecEnvoyExtraVolumesCinder;

  /**
   * configMap represents a configMap that should populate this volume
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#configMap
   */
  readonly configMap?: ContourDeploymentSpecEnvoyExtraVolumesConfigMap;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#csi
   */
  readonly csi?: ContourDeploymentSpecEnvoyExtraVolumesCsi;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#downwardAPI
   */
  readonly downwardApi?: ContourDeploymentSpecEnvoyExtraVolumesDownwardApi;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#emptyDir
   */
  readonly emptyDir?: ContourDeploymentSpecEnvoyExtraVolumesEmptyDir;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#ephemeral
   */
  readonly ephemeral?: ContourDeploymentSpecEnvoyExtraVolumesEphemeral;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#fc
   */
  readonly fc?: ContourDeploymentSpecEnvoyExtraVolumesFc;

  /**
   * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#flexVolume
   */
  readonly flexVolume?: ContourDeploymentSpecEnvoyExtraVolumesFlexVolume;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#flocker
   */
  readonly flocker?: ContourDeploymentSpecEnvoyExtraVolumesFlocker;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk;

  /**
   * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#gitRepo
   */
  readonly gitRepo?: ContourDeploymentSpecEnvoyExtraVolumesGitRepo;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#glusterfs
   */
  readonly glusterfs?: ContourDeploymentSpecEnvoyExtraVolumesGlusterfs;

  /**
   * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#hostPath
   */
  readonly hostPath?: ContourDeploymentSpecEnvoyExtraVolumesHostPath;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#iscsi
   */
  readonly iscsi?: ContourDeploymentSpecEnvoyExtraVolumesIscsi;

  /**
   * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#name
   */
  readonly name: string;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#nfs
   */
  readonly nfs?: ContourDeploymentSpecEnvoyExtraVolumesNfs;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#portworxVolume
   */
  readonly portworxVolume?: ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#projected
   */
  readonly projected?: ContourDeploymentSpecEnvoyExtraVolumesProjected;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#quobyte
   */
  readonly quobyte?: ContourDeploymentSpecEnvoyExtraVolumesQuobyte;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#rbd
   */
  readonly rbd?: ContourDeploymentSpecEnvoyExtraVolumesRbd;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#scaleIO
   */
  readonly scaleIo?: ContourDeploymentSpecEnvoyExtraVolumesScaleIo;

  /**
   * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#secret
   */
  readonly secret?: ContourDeploymentSpecEnvoyExtraVolumesSecret;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#storageos
   */
  readonly storageos?: ContourDeploymentSpecEnvoyExtraVolumesStorageos;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumes#vsphereVolume
   */
  readonly vsphereVolume?: ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumes(obj: ContourDeploymentSpecEnvoyExtraVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_ContourDeploymentSpecEnvoyExtraVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_ContourDeploymentSpecEnvoyExtraVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_ContourDeploymentSpecEnvoyExtraVolumesCephfs(obj.cephfs),
    'cinder': toJson_ContourDeploymentSpecEnvoyExtraVolumesCinder(obj.cinder),
    'configMap': toJson_ContourDeploymentSpecEnvoyExtraVolumesConfigMap(obj.configMap),
    'csi': toJson_ContourDeploymentSpecEnvoyExtraVolumesCsi(obj.csi),
    'downwardAPI': toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_ContourDeploymentSpecEnvoyExtraVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeral(obj.ephemeral),
    'fc': toJson_ContourDeploymentSpecEnvoyExtraVolumesFc(obj.fc),
    'flexVolume': toJson_ContourDeploymentSpecEnvoyExtraVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_ContourDeploymentSpecEnvoyExtraVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_ContourDeploymentSpecEnvoyExtraVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_ContourDeploymentSpecEnvoyExtraVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_ContourDeploymentSpecEnvoyExtraVolumesHostPath(obj.hostPath),
    'iscsi': toJson_ContourDeploymentSpecEnvoyExtraVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_ContourDeploymentSpecEnvoyExtraVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjected(obj.projected),
    'quobyte': toJson_ContourDeploymentSpecEnvoyExtraVolumesQuobyte(obj.quobyte),
    'rbd': toJson_ContourDeploymentSpecEnvoyExtraVolumesRbd(obj.rbd),
    'scaleIO': toJson_ContourDeploymentSpecEnvoyExtraVolumesScaleIo(obj.scaleIo),
    'secret': toJson_ContourDeploymentSpecEnvoyExtraVolumesSecret(obj.secret),
    'storageos': toJson_ContourDeploymentSpecEnvoyExtraVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkPublishing defines how to expose Envoy to a network.
 *
 * @schema ContourDeploymentSpecEnvoyNetworkPublishing
 */
export interface ContourDeploymentSpecEnvoyNetworkPublishing {
  /**
   * ExternalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs).
   * If unset, defaults to "Local".
   *
   * @schema ContourDeploymentSpecEnvoyNetworkPublishing#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * ServiceAnnotations is the annotations to add to the provisioned Envoy service.
   *
   * @schema ContourDeploymentSpecEnvoyNetworkPublishing#serviceAnnotations
   */
  readonly serviceAnnotations?: { [key: string]: string };

  /**
   * NetworkPublishingType is the type of publishing strategy to use. Valid values are:
   * * LoadBalancerService
   * In this configuration, network endpoints for Envoy use container networking. A Kubernetes LoadBalancer Service is created to publish Envoy network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer
   * * NodePortService
   * Publishes Envoy network endpoints using a Kubernetes NodePort Service.
   * In this configuration, Envoy network endpoints use container networking. A Kubernetes NodePort Service is created to publish the network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#nodeport
   * NOTE: When provisioning an Envoy `NodePortService`, use Gateway Listeners' port numbers to populate the Service's node port values, there's no way to auto-allocate them.
   * See: https://github.com/projectcontour/contour/issues/4499
   * * ClusterIPService
   * Publishes Envoy network endpoints using a Kubernetes ClusterIP Service.
   * In this configuration, Envoy network endpoints use container networking. A Kubernetes ClusterIP Service is created to publish the network endpoints.
   * See: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   * If unset, defaults to LoadBalancerService.
   *
   * @schema ContourDeploymentSpecEnvoyNetworkPublishing#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNetworkPublishing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNetworkPublishing(obj: ContourDeploymentSpecEnvoyNetworkPublishing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalTrafficPolicy': obj.externalTrafficPolicy,
    'serviceAnnotations': ((obj.serviceAnnotations) === undefined) ? undefined : (Object.entries(obj.serviceAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePlacement describes node scheduling configuration of Envoy pods.
 *
 * @schema ContourDeploymentSpecEnvoyNodePlacement
 */
export interface ContourDeploymentSpecEnvoyNodePlacement {
  /**
   * NodeSelector is the simplest recommended form of node selection constraint and specifies a map of key-value pairs. For the pod to be eligible to run on a node, the node must have each of the indicated key-value pairs as labels (it can have additional labels as well).
   * If unset, the pod(s) will be scheduled to any available node.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacement#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * Tolerations work with taints to ensure that pods are not scheduled onto inappropriate nodes. One or more taints are applied to a node; this marks that the node should not accept any pods that do not tolerate the taints.
   * The default is an empty list.
   * See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/ for additional details.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacement#tolerations
   */
  readonly tolerations?: ContourDeploymentSpecEnvoyNodePlacementTolerations[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNodePlacement' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNodePlacement(obj: ContourDeploymentSpecEnvoyNodePlacement | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tolerations': obj.tolerations?.map(y => toJson_ContourDeploymentSpecEnvoyNodePlacementTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compute Resources required by envoy container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
 *
 * @schema ContourDeploymentSpecEnvoyResources
 */
export interface ContourDeploymentSpecEnvoyResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ContourDeploymentSpecEnvoyResources#claims
   */
  readonly claims?: ContourDeploymentSpecEnvoyResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecEnvoyResources#limits
   */
  readonly limits?: { [key: string]: ContourDeploymentSpecEnvoyResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecEnvoyResources#requests
   */
  readonly requests?: { [key: string]: ContourDeploymentSpecEnvoyResourcesRequests };

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyResources(obj: ContourDeploymentSpecEnvoyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ContourDeploymentSpecEnvoyResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Debug contains parameters to enable debug logging and debug interfaces inside Contour.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsDebug
 */
export interface ContourDeploymentSpecRuntimeSettingsDebug {
  /**
   * Defines the Contour debug address interface.
   * Contour's default is "127.0.0.1".
   *
   * @schema ContourDeploymentSpecRuntimeSettingsDebug#address
   */
  readonly address?: string;

  /**
   * Defines the Contour debug address port.
   * Contour's default is 6060.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsDebug#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsDebug' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsDebug(obj: ContourDeploymentSpecRuntimeSettingsDebug | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Envoy contains parameters for Envoy as well as how to optionally configure a managed Envoy fleet.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoy
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoy {
  /**
   * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#clientCertificate
   */
  readonly clientCertificate?: ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate;

  /**
   * Cluster holds various configurable Envoy cluster values that can be set in the config file.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#cluster
   */
  readonly cluster?: ContourDeploymentSpecRuntimeSettingsEnvoyCluster;

  /**
   * DefaultHTTPVersions defines the default set of HTTPS versions the proxy should accept. HTTP versions are strings of the form "HTTP/xx". Supported versions are "HTTP/1.1" and "HTTP/2".
   * Values: `HTTP/1.1`, `HTTP/2` (default: both).
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#defaultHTTPVersions
   */
  readonly defaultHttpVersions?: string[];

  /**
   * Health defines the endpoint Envoy uses to serve health checks.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#health
   */
  readonly health?: ContourDeploymentSpecRuntimeSettingsEnvoyHealth;

  /**
   * Defines the HTTP Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#http
   */
  readonly http?: ContourDeploymentSpecRuntimeSettingsEnvoyHttp;

  /**
   * Defines the HTTPS Listener for Envoy.
   * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#https
   */
  readonly https?: ContourDeploymentSpecRuntimeSettingsEnvoyHttps;

  /**
   * Listener hold various configurable Envoy listener values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#listener
   */
  readonly listener?: ContourDeploymentSpecRuntimeSettingsEnvoyListener;

  /**
   * Logging defines how Envoy's logs can be configured.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#logging
   */
  readonly logging?: ContourDeploymentSpecRuntimeSettingsEnvoyLogging;

  /**
   * Metrics defines the endpoint Envoy uses to serve metrics.
   * Contour's default is { address: "0.0.0.0", port: 8002 }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#metrics
   */
  readonly metrics?: ContourDeploymentSpecRuntimeSettingsEnvoyMetrics;

  /**
   * Network holds various configurable Envoy network values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#network
   */
  readonly network?: ContourDeploymentSpecRuntimeSettingsEnvoyNetwork;

  /**
   * Service holds Envoy service parameters for setting Ingress status.
   * Contour's default is { namespace: "projectcontour", name: "envoy" }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#service
   */
  readonly service?: ContourDeploymentSpecRuntimeSettingsEnvoyService;

  /**
   * Timeouts holds various configurable timeouts that can be set in the config file.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoy#timeouts
   */
  readonly timeouts?: ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoy(obj: ContourDeploymentSpecRuntimeSettingsEnvoy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertificate': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate(obj.clientCertificate),
    'cluster': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyCluster(obj.cluster),
    'defaultHTTPVersions': obj.defaultHttpVersions?.map(y => y),
    'health': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHealth(obj.health),
    'http': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttp(obj.http),
    'https': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttps(obj.https),
    'listener': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListener(obj.listener),
    'logging': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyLogging(obj.logging),
    'metrics': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetrics(obj.metrics),
    'network': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyNetwork(obj.network),
    'service': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyService(obj.service),
    'timeouts': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts(obj.timeouts),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Gateway contains parameters for the gateway-api Gateway that Contour is configured to serve traffic.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGateway
 */
export interface ContourDeploymentSpecRuntimeSettingsGateway {
  /**
   * ControllerName is used to determine whether Contour should reconcile a GatewayClass. The string takes the form of "projectcontour.io/<namespace>/contour". If unset, the gatewayclass controller will not be started. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGateway#controllerName
   */
  readonly controllerName?: string;

  /**
   * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGateway#gatewayRef
   */
  readonly gatewayRef?: ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGateway' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGateway(obj: ContourDeploymentSpecRuntimeSettingsGateway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controllerName': obj.controllerName,
    'gatewayRef': toJson_ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef(obj.gatewayRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalExternalAuthorization allows envoys external authorization filter to be enabled for all virtual hosts.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth
 */
export interface ContourDeploymentSpecRuntimeSettingsGlobalExtAuth {
  /**
   * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth#authPolicy
   */
  readonly authPolicy?: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy;

  /**
   * ExtensionServiceRef specifies the extension resource that will authorize client requests.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth#extensionRef
   */
  readonly extensionRef?: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef;

  /**
   * If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". The string "infinity" is also a valid input and specifies no timeout.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth#responseTimeout
   */
  readonly responseTimeout?: string;

  /**
   * WithRequestBody specifies configuration for sending the client request's body to authorization server.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuth#withRequestBody
   */
  readonly withRequestBody?: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGlobalExtAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuth(obj: ContourDeploymentSpecRuntimeSettingsGlobalExtAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy(obj.authPolicy),
    'extensionRef': toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef(obj.extensionRef),
    'failOpen': obj.failOpen,
    'responseTimeout': obj.responseTimeout,
    'withRequestBody': toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody(obj.withRequestBody),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoints Contour uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHealth
 */
export interface ContourDeploymentSpecRuntimeSettingsHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHealth(obj: ContourDeploymentSpecRuntimeSettingsHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxy defines parameters on HTTPProxy.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy
 */
export interface ContourDeploymentSpecRuntimeSettingsHttpproxy {
  /**
   * DisablePermitInsecure disables the use of the permitInsecure field in HTTPProxy.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#disablePermitInsecure
   */
  readonly disablePermitInsecure?: boolean;

  /**
   * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#fallbackCertificate
   */
  readonly fallbackCertificate?: ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate;

  /**
   * Restrict Contour to searching these namespaces for root ingress routes.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxy#rootNamespaces
   */
  readonly rootNamespaces?: string[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHttpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHttpproxy(obj: ContourDeploymentSpecRuntimeSettingsHttpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disablePermitInsecure': obj.disablePermitInsecure,
    'fallbackCertificate': toJson_ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate(obj.fallbackCertificate),
    'rootNamespaces': obj.rootNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ingress contains parameters for ingress options.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsIngress
 */
export interface ContourDeploymentSpecRuntimeSettingsIngress {
  /**
   * Ingress Class Names Contour should use.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsIngress#classNames
   */
  readonly classNames?: string[];

  /**
   * Address to set in Ingress object status.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsIngress#statusAddress
   */
  readonly statusAddress?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsIngress' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsIngress(obj: ContourDeploymentSpecRuntimeSettingsIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'classNames': obj.classNames?.map(y => y),
    'statusAddress': obj.statusAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Contour uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8000 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsMetrics
 */
export interface ContourDeploymentSpecRuntimeSettingsMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetrics#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsMetricsTls;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsMetrics(obj: ContourDeploymentSpecRuntimeSettingsMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy specifies default policy applied if not overridden by the user
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicy
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicy {
  /**
   * ApplyToIngress determines if the Policies will apply to ingress objects
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#applyToIngress
   */
  readonly applyToIngress?: boolean;

  /**
   * RequestHeadersPolicy defines the request headers set/removed on all routes
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#requestHeaders
   */
  readonly requestHeaders?: ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders;

  /**
   * ResponseHeadersPolicy defines the response headers set/removed on all routes
   *
   * @schema ContourDeploymentSpecRuntimeSettingsPolicy#responseHeaders
   */
  readonly responseHeaders?: ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicy(obj: ContourDeploymentSpecRuntimeSettingsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyToIngress': obj.applyToIngress,
    'requestHeaders': toJson_ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders(obj.responseHeaders),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitService optionally holds properties of the Rate Limit Service to be used for global rate limiting.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService
 */
export interface ContourDeploymentSpecRuntimeSettingsRateLimitService {
  /**
   * Domain is passed to the Rate Limit Service.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#domain
   */
  readonly domain?: string;

  /**
   * EnableResourceExhaustedCode enables translating error code 429 to grpc code RESOURCE_EXHAUSTED. When disabled it's translated to UNAVAILABLE
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#enableResourceExhaustedCode
   */
  readonly enableResourceExhaustedCode?: boolean;

  /**
   * EnableXRateLimitHeaders defines whether to include the X-RateLimit headers X-RateLimit-Limit, X-RateLimit-Remaining, and X-RateLimit-Reset (as defined by the IETF Internet-Draft linked below), on responses to clients when the Rate Limit Service is consulted for a request.
   * ref. https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#enableXRateLimitHeaders
   */
  readonly enableXRateLimitHeaders?: boolean;

  /**
   * ExtensionService identifies the extension service defining the RLS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#extensionService
   */
  readonly extensionService: ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService;

  /**
   * FailOpen defines whether to allow requests to proceed when the Rate Limit Service fails to respond with a valid rate limit decision within the timeout defined on the extension service.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitService#failOpen
   */
  readonly failOpen?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsRateLimitService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsRateLimitService(obj: ContourDeploymentSpecRuntimeSettingsRateLimitService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enableResourceExhaustedCode': obj.enableResourceExhaustedCode,
    'enableXRateLimitHeaders': obj.enableXRateLimitHeaders,
    'extensionService': toJson_ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService(obj.extensionService),
    'failOpen': obj.failOpen,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Tracing defines properties for exporting trace data to OpenTelemetry.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsTracing
 */
export interface ContourDeploymentSpecRuntimeSettingsTracing {
  /**
   * CustomTags defines a list of custom tags with unique tag name.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#customTags
   */
  readonly customTags?: ContourDeploymentSpecRuntimeSettingsTracingCustomTags[];

  /**
   * ExtensionService identifies the extension service defining the otel-collector.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#extensionService
   */
  readonly extensionService: ContourDeploymentSpecRuntimeSettingsTracingExtensionService;

  /**
   * IncludePodDetail defines a flag. If it is true, contour will add the pod name and namespace to the span of the trace. the default is true. Note: The Envoy pods MUST have the HOSTNAME and CONTOUR_NAMESPACE environment variables set for this to work properly.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#includePodDetail
   */
  readonly includePodDetail?: boolean;

  /**
   * MaxPathTagLength defines maximum length of the request path to extract and include in the HttpUrl tag. contour's default is 256.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#maxPathTagLength
   */
  readonly maxPathTagLength?: number;

  /**
   * OverallSampling defines the sampling rate of trace data. contour's default is 100.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#overallSampling
   */
  readonly overallSampling?: string;

  /**
   * ServiceName defines the name for the service. contour's default is contour.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracing#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsTracing(obj: ContourDeploymentSpecRuntimeSettingsTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': obj.customTags?.map(y => toJson_ContourDeploymentSpecRuntimeSettingsTracingCustomTags(y)),
    'extensionService': toJson_ContourDeploymentSpecRuntimeSettingsTracingExtensionService(obj.extensionService),
    'includePodDetail': obj.includePodDetail,
    'maxPathTagLength': obj.maxPathTagLength,
    'overallSampling': obj.overallSampling,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * XDSServer contains parameters for the xDS server.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsXdsServer
 */
export interface ContourDeploymentSpecRuntimeSettingsXdsServer {
  /**
   * Defines the xDS gRPC API address which Contour will serve.
   * Contour's default is "0.0.0.0".
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#address
   */
  readonly address?: string;

  /**
   * Defines the xDS gRPC API port which Contour will serve.
   * Contour's default is 8001.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details.
   * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsXdsServerTls;

  /**
   * Defines the XDSServer to use for `contour serve`.
   * Values: `contour` (default), `envoy`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServer#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsXdsServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsXdsServer(obj: ContourDeploymentSpecRuntimeSettingsXdsServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsXdsServerTls(obj.tls),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Strategy describes the deployment strategy to use to replace existing pods with new pods.
 *
 * @schema ContourDeploymentSpecContourDeploymentStrategy
 */
export interface ContourDeploymentSpecContourDeploymentStrategy {
  /**
   * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
   *
   * @schema ContourDeploymentSpecContourDeploymentStrategy#rollingUpdate
   */
  readonly rollingUpdate?: ContourDeploymentSpecContourDeploymentStrategyRollingUpdate;

  /**
   * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema ContourDeploymentSpecContourDeploymentStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourDeploymentStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourDeploymentStrategy(obj: ContourDeploymentSpecContourDeploymentStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_ContourDeploymentSpecContourDeploymentStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ContourDeploymentSpecContourNodePlacementTolerations
 */
export interface ContourDeploymentSpecContourNodePlacementTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ContourDeploymentSpecContourNodePlacementTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourNodePlacementTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourNodePlacementTolerations(obj: ContourDeploymentSpecContourNodePlacementTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ContourDeploymentSpecContourResourcesClaims
 */
export interface ContourDeploymentSpecContourResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ContourDeploymentSpecContourResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourResourcesClaims(obj: ContourDeploymentSpecContourResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContourDeploymentSpecContourResourcesLimits
 */
export class ContourDeploymentSpecContourResourcesLimits {
  public static fromNumber(value: number): ContourDeploymentSpecContourResourcesLimits {
    return new ContourDeploymentSpecContourResourcesLimits(value);
  }
  public static fromString(value: string): ContourDeploymentSpecContourResourcesLimits {
    return new ContourDeploymentSpecContourResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ContourDeploymentSpecContourResourcesRequests
 */
export class ContourDeploymentSpecContourResourcesRequests {
  public static fromNumber(value: number): ContourDeploymentSpecContourResourcesRequests {
    return new ContourDeploymentSpecContourResourcesRequests(value);
  }
  public static fromString(value: string): ContourDeploymentSpecContourResourcesRequests {
    return new ContourDeploymentSpecContourResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Strategy describes the deployment strategy to use to replace existing DaemonSet pods with new pods.
 *
 * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy
 */
export interface ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy {
  /**
   * Rolling update config params. Present only if type = "RollingUpdate". --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be. Same as Deployment `strategy.rollingUpdate`. See https://github.com/kubernetes/kubernetes/issues/35345
   *
   * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate;

  /**
   * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy(obj: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Strategy describes the deployment strategy to use to replace existing pods with new pods.
 *
 * @schema ContourDeploymentSpecEnvoyDeploymentStrategy
 */
export interface ContourDeploymentSpecEnvoyDeploymentStrategy {
  /**
   * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
   *
   * @schema ContourDeploymentSpecEnvoyDeploymentStrategy#rollingUpdate
   */
  readonly rollingUpdate?: ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate;

  /**
   * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema ContourDeploymentSpecEnvoyDeploymentStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDeploymentStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDeploymentStrategy(obj: ContourDeploymentSpecEnvoyDeploymentStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rollingUpdate': toJson_ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate(obj.rollingUpdate),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * awsElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore(obj: ContourDeploymentSpecEnvoyExtraVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesAzureDisk {
  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * fsType is Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesAzureDisk(obj: ContourDeploymentSpecEnvoyExtraVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureFile
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesAzureFile {
  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesAzureFile(obj: ContourDeploymentSpecEnvoyExtraVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCephfs {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef;

  /**
   * user is optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCephfs(obj: ContourDeploymentSpecEnvoyExtraVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCinder
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCinder {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCinder#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef;

  /**
   * volumeID used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCinder(obj: ContourDeploymentSpecEnvoyExtraVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap represents a configMap that should populate this volume
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMap
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesConfigMap {
  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMap#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesConfigMap(obj: ContourDeploymentSpecEnvoyExtraVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCsi {
  /**
   * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef;

  /**
   * readOnly specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCsi(obj: ContourDeploymentSpecEnvoyExtraVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApi
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApi#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApi(obj: ContourDeploymentSpecEnvoyExtraVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * emptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEmptyDir
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEmptyDir {
  /**
   * medium represents what type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEmptyDir(obj: ContourDeploymentSpecEnvoyExtraVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through a PersistentVolumeClaim (see EphemeralVolumeSource for more information on the connection between this volume type and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeral
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeral(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesFc
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesFc {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * lun is Optional: FC target lun number
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * wwids Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesFc(obj: ContourDeploymentSpecEnvoyExtraVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesFlexVolume {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * options is Optional: this field holds extra command options if any.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolume#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesFlexVolume(obj: ContourDeploymentSpecEnvoyExtraVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesFlocker
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesFlocker {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesFlocker(obj: ContourDeploymentSpecEnvoyExtraVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gcePersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk {
  /**
   * fsType is filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * partition is the partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk(obj: ContourDeploymentSpecEnvoyExtraVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * gitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesGitRepo
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesGitRepo {
  /**
   * directory is the target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * repository is the URL
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * revision is the commit hash for the specified revision.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesGitRepo(obj: ContourDeploymentSpecEnvoyExtraVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesGlusterfs
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesGlusterfs {
  /**
   * endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema ContourDeploymentSpecEnvoyExtraVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesGlusterfs(obj: ContourDeploymentSpecEnvoyExtraVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * hostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesHostPath
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesHostPath {
  /**
   * path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesHostPath#path
   */
  readonly path: string;

  /**
   * type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema ContourDeploymentSpecEnvoyExtraVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesHostPath(obj: ContourDeploymentSpecEnvoyExtraVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesIscsi {
  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * initiatorName is the custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef;

  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesIscsi(obj: ContourDeploymentSpecEnvoyExtraVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nfs represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesNfs
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesNfs {
  /**
   * path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesNfs#path
   */
  readonly path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema ContourDeploymentSpecEnvoyExtraVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesNfs(obj: ContourDeploymentSpecEnvoyExtraVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * persistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim(obj: ContourDeploymentSpecEnvoyExtraVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk(obj: ContourDeploymentSpecEnvoyExtraVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume {
  /**
   * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume(obj: ContourDeploymentSpecEnvoyExtraVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * projected items for all in one resources secrets, configmaps, and downward API
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjected
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjected {
  /**
   * defaultMode are the mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * sources is the list of volume projections
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjected#sources
   */
  readonly sources?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSources[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjected(obj: ContourDeploymentSpecEnvoyExtraVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesQuobyte {
  /**
   * group to map volume access to Default is no group
   *
   * @default no group
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * user to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesQuobyte(obj: ContourDeploymentSpecEnvoyExtraVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesRbd {
  /**
   * fsType is the filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#image
   */
  readonly image: string;

  /**
   * keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef;

  /**
   * user is the rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesRbd(obj: ContourDeploymentSpecEnvoyExtraVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesScaleIo {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#secretRef
   */
  readonly secretRef: ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesScaleIo(obj: ContourDeploymentSpecEnvoyExtraVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesSecret
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesSecret {
  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecret#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesSecretItems[];

  /**
   * optional field specify whether the Secret or its keys must be defined
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * secretName is the name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesSecret(obj: ContourDeploymentSpecEnvoyExtraVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesStorageos {
  /**
   * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos#secretRef
   */
  readonly secretRef?: ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef;

  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesStorageos(obj: ContourDeploymentSpecEnvoyExtraVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume {
  /**
   * fsType is filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume(obj: ContourDeploymentSpecEnvoyExtraVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations
 */
export interface ContourDeploymentSpecEnvoyNodePlacementTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema ContourDeploymentSpecEnvoyNodePlacementTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyNodePlacementTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyNodePlacementTolerations(obj: ContourDeploymentSpecEnvoyNodePlacementTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ContourDeploymentSpecEnvoyResourcesClaims
 */
export interface ContourDeploymentSpecEnvoyResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ContourDeploymentSpecEnvoyResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyResourcesClaims(obj: ContourDeploymentSpecEnvoyResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContourDeploymentSpecEnvoyResourcesLimits
 */
export class ContourDeploymentSpecEnvoyResourcesLimits {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyResourcesLimits {
    return new ContourDeploymentSpecEnvoyResourcesLimits(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyResourcesLimits {
    return new ContourDeploymentSpecEnvoyResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ContourDeploymentSpecEnvoyResourcesRequests
 */
export class ContourDeploymentSpecEnvoyResourcesRequests {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyResourcesRequests {
    return new ContourDeploymentSpecEnvoyResourcesRequests(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyResourcesRequests {
    return new ContourDeploymentSpecEnvoyResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ClientCertificate defines the namespace/name of the Kubernetes secret containing the client certificate and private key to be used when establishing TLS connection to upstream cluster.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate(obj: ContourDeploymentSpecRuntimeSettingsEnvoyClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cluster holds various configurable Envoy cluster values that can be set in the config file.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyCluster
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyCluster {
  /**
   * DNSLookupFamily defines how external names are looked up When configured as V4, the DNS resolver will only perform a lookup for addresses in the IPv4 family. If V6 is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If AUTO is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families, and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for upstream connections. Refer to Happy Eyeballs Support for more information. Note: This only applies to externalName clusters.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
   * Values: `auto` (default), `v4`, `v6`, `all`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyCluster#dnsLookupFamily
   */
  readonly dnsLookupFamily?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyCluster(obj: ContourDeploymentSpecRuntimeSettingsEnvoyCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsLookupFamily': obj.dnsLookupFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Health defines the endpoint Envoy uses to serve health checks.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHealth {
  /**
   * Defines the health address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth#address
   */
  readonly address?: string;

  /**
   * Defines the health port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHealth#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHealth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHealth(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHealth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTP Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8080, accessLog: "/dev/stdout" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHttp {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttp#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttp(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the HTTPS Listener for Envoy.
 * Contour's default is { address: "0.0.0.0", port: 8443, accessLog: "/dev/stdout" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyHttps {
  /**
   * AccessLog defines where Envoy logs are outputted for this listener.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#accessLog
   */
  readonly accessLog?: string;

  /**
   * Defines an Envoy Listener Address.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#address
   */
  readonly address?: string;

  /**
   * Defines an Envoy listener Port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyHttps#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyHttps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyHttps(obj: ContourDeploymentSpecRuntimeSettingsEnvoyHttps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLog': obj.accessLog,
    'address': obj.address,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Listener hold various configurable Envoy listener values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyListener {
  /**
   * ConnectionBalancer. If the value is exact, the listener will use the exact connection balancer See https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener.proto#envoy-api-msg-listener-connectionbalanceconfig for more information.
   * Values: (empty string): use the default ConnectionBalancer, `exact`: use the Exact ConnectionBalancer.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#connectionBalancer
   */
  readonly connectionBalancer?: string;

  /**
   * DisableAllowChunkedLength disables the RFC-compliant Envoy behavior to strip the "Content-Length" header if "Transfer-Encoding: chunked" is also set. This is an emergency off-switch to revert back to Envoy's default behavior in case of failures. Please file an issue if failures are encountered. See: https://github.com/projectcontour/contour/issues/3221
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#disableAllowChunkedLength
   */
  readonly disableAllowChunkedLength?: boolean;

  /**
   * DisableMergeSlashes disables Envoy's non-standard merge_slashes path transformation option which strips duplicate slashes from request URL paths.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#disableMergeSlashes
   */
  readonly disableMergeSlashes?: boolean;

  /**
   * Defines the action to be applied to the Server header on the response path. When configured as overwrite, overwrites any Server header with "envoy". When configured as append_if_absent, if a Server header is present, pass it through, otherwise set it to "envoy". When configured as pass_through, pass through the value of the Server header, and do not append a header if none is present.
   * Values: `overwrite` (default), `append_if_absent`, `pass_through`
   * Other values will produce an error. Contour's default is overwrite.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#serverHeaderTransformation
   */
  readonly serverHeaderTransformation?: string;

  /**
   * TLS holds various configurable Envoy TLS listener values.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls;

  /**
   * Use PROXY protocol for all listeners.
   * Contour's default is false.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListener#useProxyProtocol
   */
  readonly useProxyProtocol?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListener(obj: ContourDeploymentSpecRuntimeSettingsEnvoyListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionBalancer': obj.connectionBalancer,
    'disableAllowChunkedLength': obj.disableAllowChunkedLength,
    'disableMergeSlashes': obj.disableMergeSlashes,
    'serverHeaderTransformation': obj.serverHeaderTransformation,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls(obj.tls),
    'useProxyProtocol': obj.useProxyProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging defines how Envoy's logs can be configured.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyLogging {
  /**
   * AccessLogFormat sets the global access log format.
   * Values: `envoy` (default), `json`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogFormat
   */
  readonly accessLogFormat?: string;

  /**
   * AccessLogFormatString sets the access log format when format is set to `envoy`. When empty, Envoy's default format is used.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogFormatString
   */
  readonly accessLogFormatString?: string;

  /**
   * AccessLogJSONFields sets the fields that JSON logging will output when AccessLogFormat is json.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogJSONFields
   */
  readonly accessLogJsonFields?: string[];

  /**
   * AccessLogLevel sets the verbosity level of the access log.
   * Values: `info` (default, meaning all requests are logged), `error` and `disabled`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyLogging#accessLogLevel
   */
  readonly accessLogLevel?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyLogging(obj: ContourDeploymentSpecRuntimeSettingsEnvoyLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogFormat': obj.accessLogFormat,
    'accessLogFormatString': obj.accessLogFormatString,
    'accessLogJSONFields': obj.accessLogJsonFields?.map(y => y),
    'accessLogLevel': obj.accessLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics defines the endpoint Envoy uses to serve metrics.
 * Contour's default is { address: "0.0.0.0", port: 8002 }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyMetrics {
  /**
   * Defines the metrics address interface.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#address
   */
  readonly address?: string;

  /**
   * Defines the metrics port.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#port
   */
  readonly port?: number;

  /**
   * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetrics#tls
   */
  readonly tls?: ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetrics(obj: ContourDeploymentSpecRuntimeSettingsEnvoyMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'port': obj.port,
    'tls': toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Network holds various configurable Envoy network values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyNetwork {
  /**
   * Configure the port used to access the Envoy Admin interface. If configured to port "0" then the admin interface is disabled.
   * Contour's default is 9001.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork#adminPort
   */
  readonly adminPort?: number;

  /**
   * XffNumTrustedHops defines the number of additional ingress proxy hops from the right side of the x-forwarded-for HTTP header to trust when determining the origin client’s IP address.
   * See https://www.envoyproxy.io/docs/envoy/v1.17.0/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto?highlight=xff_num_trusted_hops for more information.
   * Contour's default is 0.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyNetwork#numTrustedHops
   */
  readonly numTrustedHops?: number;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyNetwork(obj: ContourDeploymentSpecRuntimeSettingsEnvoyNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adminPort': obj.adminPort,
    'numTrustedHops': obj.numTrustedHops,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service holds Envoy service parameters for setting Ingress status.
 * Contour's default is { namespace: "projectcontour", name: "envoy" }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyService {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyService(obj: ContourDeploymentSpecRuntimeSettingsEnvoyService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Timeouts holds various configurable timeouts that can be set in the config file.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts {
  /**
   * ConnectTimeout defines how long the proxy should wait when establishing connection to upstream service. If not set, a default value of 2 seconds will be used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-connect-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * ConnectionIdleTimeout defines how long the proxy should wait while there are no active requests (for HTTP/1.1) or streams (for HTTP/2) before terminating an HTTP connection. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-idle-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectionIdleTimeout
   */
  readonly connectionIdleTimeout?: string;

  /**
   * ConnectionShutdownGracePeriod defines how long the proxy will wait between sending an initial GOAWAY frame and a second, final GOAWAY frame when terminating an HTTP/2 connection. During this grace period, the proxy will continue to respond to new streams. After the final GOAWAY frame has been sent, the proxy will refuse new streams.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-drain-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#connectionShutdownGracePeriod
   */
  readonly connectionShutdownGracePeriod?: string;

  /**
   * DelayedCloseTimeout defines how long envoy will wait, once connection close processing has been initiated, for the downstream peer to close the connection before Envoy closes the socket associated with the connection.
   * Setting this timeout to 'infinity' will disable it, equivalent to setting it to '0' in Envoy. Leaving it unset will result in the Envoy default value being used.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-delayed-close-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#delayedCloseTimeout
   */
  readonly delayedCloseTimeout?: string;

  /**
   * MaxConnectionDuration defines the maximum period of time after an HTTP connection has been established from the client to the proxy before it is closed by the proxy, regardless of whether there has been activity or not. Omit or set to "infinity" for no max duration.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * RequestTimeout sets the client request timeout globally for Contour. Note that this is a timeout for the entire request, not an idle timeout. Omit or set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-request-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#requestTimeout
   */
  readonly requestTimeout?: string;

  /**
   * StreamIdleTimeout defines how long the proxy should wait while there is no request activity (for HTTP/1.1) or stream activity (for HTTP/2) before terminating the HTTP request or stream. Set to "infinity" to disable the timeout entirely.
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-stream-idle-timeout for more information.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts#streamIdleTimeout
   */
  readonly streamIdleTimeout?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts(obj: ContourDeploymentSpecRuntimeSettingsEnvoyTimeouts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'connectionIdleTimeout': obj.connectionIdleTimeout,
    'connectionShutdownGracePeriod': obj.connectionShutdownGracePeriod,
    'delayedCloseTimeout': obj.delayedCloseTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'requestTimeout': obj.requestTimeout,
    'streamIdleTimeout': obj.streamIdleTimeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GatewayRef defines a specific Gateway that this Contour instance corresponds to. If set, Contour will reconcile only this gateway, and will not reconcile any gateway classes. Exactly one of ControllerName or GatewayRef must be set.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef
 */
export interface ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef(obj: ContourDeploymentSpecRuntimeSettingsGatewayGatewayRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy
 */
export interface ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy(obj: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceRef specifies the extension resource that will authorize client requests.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef
 */
export interface ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef {
  /**
   * API version of the referent. If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef(obj: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthExtensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WithRequestBody specifies configuration for sending the client request's body to authorization server.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody
 */
export interface ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody {
  /**
   * If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody#allowPartialMessage
   */
  readonly allowPartialMessage?: boolean;

  /**
   * MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody#maxRequestBytes
   */
  readonly maxRequestBytes?: number;

  /**
   * If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody#packAsBytes
   */
  readonly packAsBytes?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody(obj: ContourDeploymentSpecRuntimeSettingsGlobalExtAuthWithRequestBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPartialMessage': obj.allowPartialMessage,
    'maxRequestBytes': obj.maxRequestBytes,
    'packAsBytes': obj.packAsBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FallbackCertificate defines the namespace/name of the Kubernetes secret to use as fallback when a non-SNI request is received.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate
 */
export interface ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate(obj: ContourDeploymentSpecRuntimeSettingsHttpproxyFallbackCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls
 */
export interface ContourDeploymentSpecRuntimeSettingsMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsMetricsTls(obj: ContourDeploymentSpecRuntimeSettingsMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeadersPolicy defines the request headers set/removed on all routes
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders(obj: ContourDeploymentSpecRuntimeSettingsPolicyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResponseHeadersPolicy defines the response headers set/removed on all routes
 *
 * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders
 */
export interface ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders#remove
   */
  readonly remove?: string[];

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders(obj: ContourDeploymentSpecRuntimeSettingsPolicyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the RLS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService
 */
export interface ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService(obj: ContourDeploymentSpecRuntimeSettingsRateLimitServiceExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomTag defines custom tags with unique tag name to create tags for the active span.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsTracingCustomTags
 */
export interface ContourDeploymentSpecRuntimeSettingsTracingCustomTags {
  /**
   * Literal is a static custom tag value. Precisely one of Literal, RequestHeaderName must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracingCustomTags#literal
   */
  readonly literal?: string;

  /**
   * RequestHeaderName indicates which request header the label value is obtained from. Precisely one of Literal, RequestHeaderName must be set.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracingCustomTags#requestHeaderName
   */
  readonly requestHeaderName?: string;

  /**
   * TagName is the unique name of the custom tag.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsTracingCustomTags#tagName
   */
  readonly tagName: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsTracingCustomTags(obj: ContourDeploymentSpecRuntimeSettingsTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'literal': obj.literal,
    'requestHeaderName': obj.requestHeaderName,
    'tagName': obj.tagName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionService identifies the extension service defining the otel-collector.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsTracingExtensionService
 */
export interface ContourDeploymentSpecRuntimeSettingsTracingExtensionService {
  /**
   * @schema ContourDeploymentSpecRuntimeSettingsTracingExtensionService#name
   */
  readonly name: string;

  /**
   * @schema ContourDeploymentSpecRuntimeSettingsTracingExtensionService#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsTracingExtensionService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsTracingExtensionService(obj: ContourDeploymentSpecRuntimeSettingsTracingExtensionService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details.
 * Contour's default is { caFile: "/certs/ca.crt", certFile: "/certs/tls.cert", keyFile: "/certs/tls.key", insecure: false }.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls
 */
export interface ContourDeploymentSpecRuntimeSettingsXdsServerTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#certFile
   */
  readonly certFile?: string;

  /**
   * Allow serving the xDS gRPC API without TLS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#insecure
   */
  readonly insecure?: boolean;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsXdsServerTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsXdsServerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsXdsServerTls(obj: ContourDeploymentSpecRuntimeSettingsXdsServerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'insecure': obj.insecure,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
 *
 * @schema ContourDeploymentSpecContourDeploymentStrategyRollingUpdate
 */
export interface ContourDeploymentSpecContourDeploymentStrategyRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
   *
   * @default 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
   * @schema ContourDeploymentSpecContourDeploymentStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
   *
   * @default 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
   * @schema ContourDeploymentSpecContourDeploymentStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'ContourDeploymentSpecContourDeploymentStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecContourDeploymentStrategyRollingUpdate(obj: ContourDeploymentSpecContourDeploymentStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rolling update config params. Present only if type = "RollingUpdate". --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be. Same as Deployment `strategy.rollingUpdate`. See https://github.com/kubernetes/kubernetes/issues/35345
 *
 * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate
 */
export interface ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate {
  /**
   * The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption.
   *
   * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
   *
   * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate(obj: ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
 *
 * @schema ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate
 */
export interface ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate {
  /**
   * The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
   *
   * @default 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
   * @schema ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate#maxSurge
   */
  readonly maxSurge?: ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge;

  /**
   * The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
   *
   * @default 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
   * @schema ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate(obj: ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxSurge': obj.maxSurge?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems(obj: ContourDeploymentSpecEnvoyExtraVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * nodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems(obj: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * sizeLimit is the total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit
 */
export class ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit {
    return new ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit {
    return new ContourDeploymentSpecEnvoyExtraVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is Optional: secretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is the CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSources
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSources {
  /**
   * configMap information about the configMap data to project
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSources#configMap
   */
  readonly configMap?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap;

  /**
   * downwardAPI information about the downwardAPI data to project
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi;

  /**
   * secret information about the secret data to project
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSources#secret
   */
  readonly secret?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSources(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesSecretItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesSecretItems(obj: ContourDeploymentSpecEnvoyExtraVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef(obj: ContourDeploymentSpecEnvoyExtraVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds various configurable Envoy TLS listener values.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls {
  /**
   * CipherSuites defines the TLS ciphers to be supported by Envoy TLS listeners when negotiating TLS 1.2. Ciphers are validated against the set that Envoy supports by default. This parameter should only be used by advanced users. Note that these will be ignored when TLS 1.3 is in use.
   * This field is optional; when it is undefined, a Contour-managed ciphersuite list will be used, which may be updated to keep it secure.
   * Contour's default list is: - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]" - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]" - "ECDHE-ECDSA-AES256-GCM-SHA384" - "ECDHE-RSA-AES256-GCM-SHA384"
   * Ciphers provided are validated against the following list: - "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]" - "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]" - "ECDHE-ECDSA-AES128-GCM-SHA256" - "ECDHE-RSA-AES128-GCM-SHA256" - "ECDHE-ECDSA-AES128-SHA" - "ECDHE-RSA-AES128-SHA" - "AES128-GCM-SHA256" - "AES128-SHA" - "ECDHE-ECDSA-AES256-GCM-SHA384" - "ECDHE-RSA-AES256-GCM-SHA384" - "ECDHE-ECDSA-AES256-SHA" - "ECDHE-RSA-AES256-SHA" - "AES256-GCM-SHA384" - "AES256-SHA"
   * Contour recommends leaving this undefined unless you are sure you must.
   * See: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto#extensions-transport-sockets-tls-v3-tlsparameters Note: This list is a superset of what is valid for stock Envoy builds and those using BoringSSL FIPS.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate.
   * Values: `1.2` (default), `1.3`.
   * Other values will produce an error.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls(obj: ContourDeploymentSpecRuntimeSettingsEnvoyListenerTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'minimumProtocolVersion': obj.minimumProtocolVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS holds TLS file config details. Metrics and health endpoints cannot have same port number when metrics is served over HTTPS.
 *
 * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls
 */
export interface ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls {
  /**
   * CA filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#caFile
   */
  readonly caFile?: string;

  /**
   * Client certificate filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#certFile
   */
  readonly certFile?: string;

  /**
   * Client key filename.
   *
   * @schema ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls#keyFile
   */
  readonly keyFile?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls(obj: ContourDeploymentSpecRuntimeSettingsEnvoyMetricsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caFile': obj.caFile,
    'certFile': obj.certFile,
    'keyFile': obj.keyFile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
 *
 * @default 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
 * @schema ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge
 */
export class ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
 *
 * @default 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
 * @schema ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable
 */
export class ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecContourDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption.
 *
 * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge
 */
export class ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0 if MaxSurge is 0 Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
 *
 * @schema ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable
 */
export class ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecEnvoyDaemonSetUpdateStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
 *
 * @default 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
 * @schema ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge
 */
export class ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge {
    return new ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxSurge(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
 *
 * @default 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
 * @schema ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable
 */
export class ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable {
    return new ContourDeploymentSpecEnvoyDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef(obj: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef(obj: ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * selector is a label query over volumes to consider for binding.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * configMap information about the configMap data to project
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * downwardAPI information about the downwardAPI data to project
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * secret information about the secret data to project
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret {
  /**
   * items if unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret#items
   */
  readonly items?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * optional field specify whether the Secret or its key must be defined
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * serviceAccountToken is information about the serviceAccountToken data to project
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken {
  /**
   * audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * expirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * path is the path relative to the mount point of the file to project the token into.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new ContourDeploymentSpecEnvoyExtraVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
   * This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
   * This field is immutable. It can only be set for containers.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources#claims
   */
  readonly claims?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims[];

  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(y)),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * selector is a label query over volumes to consider for binding.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems {
  /**
   * key is the key to project.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems {
  /**
   * key is the key to project.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceClaim references one entry in PodSpec.ResourceClaims.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims {
  /**
   * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: ContourDeploymentSpecEnvoyExtraVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new ContourDeploymentSpecEnvoyExtraVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.
 *
 * @schema ExtensionService
 */
export class ExtensionService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExtensionService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1alpha1',
    kind: 'ExtensionService',
  }

  /**
   * Renders a Kubernetes manifest for "ExtensionService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExtensionServiceProps = {}): any {
    return {
      ...ExtensionService.GVK,
      ...toJson_ExtensionServiceProps(props),
    };
  }

  /**
   * Defines a "ExtensionService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExtensionServiceProps = {}) {
    super(scope, id, {
      ...ExtensionService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExtensionService.GVK,
      ...toJson_ExtensionServiceProps(resolved),
    };
  }
}

/**
 * ExtensionService is the schema for the Contour extension services API. An ExtensionService resource binds a network service to the Contour API so that Contour API features can be implemented by collaborating components.
 *
 * @schema ExtensionService
 */
export interface ExtensionServiceProps {
  /**
   * @schema ExtensionService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExtensionServiceSpec defines the desired state of an ExtensionService resource.
   *
   * @schema ExtensionService#spec
   */
  readonly spec?: ExtensionServiceSpec;

}

/**
 * Converts an object of type 'ExtensionServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceProps(obj: ExtensionServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExtensionServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceSpec defines the desired state of an ExtensionService resource.
 *
 * @schema ExtensionServiceSpec
 */
export interface ExtensionServiceSpec {
  /**
   * The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
   *
   * @schema ExtensionServiceSpec#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: ExtensionServiceSpecLoadBalancerPolicy;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema ExtensionServiceSpec#protocol
   */
  readonly protocol?: ExtensionServiceSpecProtocol;

  /**
   * This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at "v3". However, other protocol options will be available in future.
   *
   * @schema ExtensionServiceSpec#protocolVersion
   */
  readonly protocolVersion?: ExtensionServiceSpecProtocolVersion;

  /**
   * Services specifies the set of Kubernetes Service resources that receive GRPC extension API requests. If no weights are specified for any of the entries in this array, traffic will be spread evenly across all the services. Otherwise, traffic is balanced proportionally to the Weight field in each entry.
   *
   * @schema ExtensionServiceSpec#services
   */
  readonly services: ExtensionServiceSpecServices[];

  /**
   * The timeout policy for requests to the services.
   *
   * @schema ExtensionServiceSpec#timeoutPolicy
   */
  readonly timeoutPolicy?: ExtensionServiceSpecTimeoutPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema ExtensionServiceSpec#validation
   */
  readonly validation?: ExtensionServiceSpecValidation;

}

/**
 * Converts an object of type 'ExtensionServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpec(obj: ExtensionServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loadBalancerPolicy': toJson_ExtensionServiceSpecLoadBalancerPolicy(obj.loadBalancerPolicy),
    'protocol': obj.protocol,
    'protocolVersion': obj.protocolVersion,
    'services': obj.services?.map(y => toJson_ExtensionServiceSpecServices(y)),
    'timeoutPolicy': toJson_ExtensionServiceSpecTimeoutPolicy(obj.timeoutPolicy),
    'validation': toJson_ExtensionServiceSpecValidation(obj.validation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for load balancing GRPC service requests. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicy
 */
export interface ExtensionServiceSpecLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back to the default `RoundRobin`.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicy(obj: ExtensionServiceSpecLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be h2 or h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema ExtensionServiceSpecProtocol
 */
export enum ExtensionServiceSpecProtocol {
  /** h2 */
  H2 = "h2",
  /** h2c */
  H2C = "h2c",
}

/**
 * This field sets the version of the GRPC protocol that Envoy uses to send requests to the extension service. Since Contour always uses the v3 Envoy API, this is currently fixed at "v3". However, other protocol options will be available in future.
 *
 * @schema ExtensionServiceSpecProtocolVersion
 */
export enum ExtensionServiceSpecProtocolVersion {
  /** v3 */
  V3 = "v3",
}

/**
 * ExtensionServiceTarget defines an Kubernetes Service to target with extension service traffic.
 *
 * @schema ExtensionServiceSpecServices
 */
export interface ExtensionServiceSpecServices {
  /**
   * Name is the name of Kubernetes service that will accept service traffic.
   *
   * @schema ExtensionServiceSpecServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema ExtensionServiceSpecServices#port
   */
  readonly port: number;

  /**
   * Weight defines proportion of traffic to balance to the Kubernetes Service.
   *
   * @schema ExtensionServiceSpecServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ExtensionServiceSpecServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecServices(obj: ExtensionServiceSpecServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'port': obj.port,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The timeout policy for requests to the services.
 *
 * @schema ExtensionServiceSpecTimeoutPolicy
 */
export interface ExtensionServiceSpecTimeoutPolicy {
  /**
   * Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#idle
   */
  readonly idle?: string;

  /**
   * Timeout for how long connection from the proxy to the upstream service is kept when there are no active requests. If not supplied, Envoy's default value of 1h applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#idleConnection
   */
  readonly idleConnection?: string;

  /**
   * Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.
   *
   * @schema ExtensionServiceSpecTimeoutPolicy#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecTimeoutPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecTimeoutPolicy(obj: ExtensionServiceSpecTimeoutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle,
    'idleConnection': obj.idleConnection,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema ExtensionServiceSpecValidation
 */
export interface ExtensionServiceSpecValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema ExtensionServiceSpecValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema ExtensionServiceSpecValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecValidation(obj: ExtensionServiceSpecValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: ExtensionServiceSpecLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HTTPProxy is an Ingress CRD specification.
 *
 * @schema HTTPProxy
 */
export class HttpProxy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HTTPProxy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1',
    kind: 'HTTPProxy',
  }

  /**
   * Renders a Kubernetes manifest for "HTTPProxy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HttpProxyProps): any {
    return {
      ...HttpProxy.GVK,
      ...toJson_HttpProxyProps(props),
    };
  }

  /**
   * Defines a "HTTPProxy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HttpProxyProps) {
    super(scope, id, {
      ...HttpProxy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HttpProxy.GVK,
      ...toJson_HttpProxyProps(resolved),
    };
  }
}

/**
 * HTTPProxy is an Ingress CRD specification.
 *
 * @schema HTTPProxy
 */
export interface HttpProxyProps {
  /**
   * @schema HTTPProxy#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * HTTPProxySpec defines the spec of the CRD.
   *
   * @schema HTTPProxy#spec
   */
  readonly spec: HttpProxySpec;

}

/**
 * Converts an object of type 'HttpProxyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxyProps(obj: HttpProxyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HttpProxySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPProxySpec defines the spec of the CRD.
 *
 * @schema HttpProxySpec
 */
export interface HttpProxySpec {
  /**
   * Includes allow for specific routing configuration to be included from another HTTPProxy, possibly in another namespace.
   *
   * @schema HttpProxySpec#includes
   */
  readonly includes?: HttpProxySpecIncludes[];

  /**
   * IngressClassName optionally specifies the ingress class to use for this HTTPProxy. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it is given precedence over this field.
   *
   * @schema HttpProxySpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * Routes are the ingress routes. If TCPProxy is present, Routes is ignored.
   *
   * @schema HttpProxySpec#routes
   */
  readonly routes?: HttpProxySpecRoutes[];

  /**
   * TCPProxy holds TCP proxy information.
   *
   * @schema HttpProxySpec#tcpproxy
   */
  readonly tcpproxy?: HttpProxySpecTcpproxy;

  /**
   * Virtualhost appears at most once. If it is present, the object is considered to be a "root" HTTPProxy.
   *
   * @schema HttpProxySpec#virtualhost
   */
  readonly virtualhost?: HttpProxySpecVirtualhost;

}

/**
 * Converts an object of type 'HttpProxySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpec(obj: HttpProxySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includes': obj.includes?.map(y => toJson_HttpProxySpecIncludes(y)),
    'ingressClassName': obj.ingressClassName,
    'routes': obj.routes?.map(y => toJson_HttpProxySpecRoutes(y)),
    'tcpproxy': toJson_HttpProxySpecTcpproxy(obj.tcpproxy),
    'virtualhost': toJson_HttpProxySpecVirtualhost(obj.virtualhost),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Include describes a set of policies that can be applied to an HTTPProxy in a namespace.
 *
 * @schema HttpProxySpecIncludes
 */
export interface HttpProxySpecIncludes {
  /**
   * Conditions are a set of rules that are applied to included HTTPProxies. In effect, they are added onto the Conditions of included HTTPProxy Route structs. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the include invalid.
   *
   * @schema HttpProxySpecIncludes#conditions
   */
  readonly conditions?: HttpProxySpecIncludesConditions[];

  /**
   * Name of the HTTPProxy
   *
   * @schema HttpProxySpecIncludes#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecIncludes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludes(obj: HttpProxySpecIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_HttpProxySpecIncludesConditions(y)),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route contains the set of routes for a virtual host.
 *
 * @schema HttpProxySpecRoutes
 */
export interface HttpProxySpecRoutes {
  /**
   * AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.
   *
   * @schema HttpProxySpecRoutes#authPolicy
   */
  readonly authPolicy?: HttpProxySpecRoutesAuthPolicy;

  /**
   * Conditions are a set of rules that are applied to a Route. When applied, they are merged using AND, with one exception: There can be only one Prefix MatchCondition per Conditions slice. More than one Prefix, or contradictory Conditions, will make the route invalid.
   *
   * @schema HttpProxySpecRoutes#conditions
   */
  readonly conditions?: HttpProxySpecRoutesConditions[];

  /**
   * The policies for rewriting Set-Cookie header attributes. Note that rewritten cookie names must be unique in this list. Order rewrite policies are specified in does not matter.
   *
   * @schema HttpProxySpecRoutes#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecRoutesCookieRewritePolicies[];

  /**
   * DirectResponsePolicy returns an arbitrary HTTP response directly.
   *
   * @schema HttpProxySpecRoutes#directResponsePolicy
   */
  readonly directResponsePolicy?: HttpProxySpecRoutesDirectResponsePolicy;

  /**
   * Enables websocket support for the route.
   *
   * @schema HttpProxySpecRoutes#enableWebsockets
   */
  readonly enableWebsockets?: boolean;

  /**
   * The health check policy for this route.
   *
   * @schema HttpProxySpecRoutes#healthCheckPolicy
   */
  readonly healthCheckPolicy?: HttpProxySpecRoutesHealthCheckPolicy;

  /**
   * The policy to define when to handle redirects responses internally.
   *
   * @schema HttpProxySpecRoutes#internalRedirectPolicy
   */
  readonly internalRedirectPolicy?: HttpProxySpecRoutesInternalRedirectPolicy;

  /**
   * IPAllowFilterPolicy is a list of ipv4/6 filter rules for which matching requests should be allowed. All other requests will be denied. Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined. The rules defined here override any rules set on the root HTTPProxy.
   *
   * @schema HttpProxySpecRoutes#ipAllowPolicy
   */
  readonly ipAllowPolicy?: HttpProxySpecRoutesIpAllowPolicy[];

  /**
   * IPDenyFilterPolicy is a list of ipv4/6 filter rules for which matching requests should be denied. All other requests will be allowed. Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined. The rules defined here override any rules set on the root HTTPProxy.
   *
   * @schema HttpProxySpecRoutes#ipDenyPolicy
   */
  readonly ipDenyPolicy?: HttpProxySpecRoutesIpDenyPolicy[];

  /**
   * The policy for verifying JWTs for requests to this route.
   *
   * @schema HttpProxySpecRoutes#jwtVerificationPolicy
   */
  readonly jwtVerificationPolicy?: HttpProxySpecRoutesJwtVerificationPolicy;

  /**
   * The load balancing policy for this route.
   *
   * @schema HttpProxySpecRoutes#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: HttpProxySpecRoutesLoadBalancerPolicy;

  /**
   * The policy for rewriting the path of the request URL after the request has been routed to a Service.
   *
   * @schema HttpProxySpecRoutes#pathRewritePolicy
   */
  readonly pathRewritePolicy?: HttpProxySpecRoutesPathRewritePolicy;

  /**
   * Allow this path to respond to insecure requests over HTTP which are normally not permitted when a `virtualhost.tls` block is present.
   *
   * @schema HttpProxySpecRoutes#permitInsecure
   */
  readonly permitInsecure?: boolean;

  /**
   * The policy for rate limiting on the route.
   *
   * @schema HttpProxySpecRoutes#rateLimitPolicy
   */
  readonly rateLimitPolicy?: HttpProxySpecRoutesRateLimitPolicy;

  /**
   * The policy for managing request headers during proxying.
   *
   * @schema HttpProxySpecRoutes#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecRoutesRequestHeadersPolicy;

  /**
   * RequestRedirectPolicy defines an HTTP redirection.
   *
   * @schema HttpProxySpecRoutes#requestRedirectPolicy
   */
  readonly requestRedirectPolicy?: HttpProxySpecRoutesRequestRedirectPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecRoutes#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecRoutesResponseHeadersPolicy;

  /**
   * The retry policy for this route.
   *
   * @schema HttpProxySpecRoutes#retryPolicy
   */
  readonly retryPolicy?: HttpProxySpecRoutesRetryPolicy;

  /**
   * Services are the services to proxy traffic.
   *
   * @schema HttpProxySpecRoutes#services
   */
  readonly services?: HttpProxySpecRoutesServices[];

  /**
   * The timeout policy for this route.
   *
   * @schema HttpProxySpecRoutes#timeoutPolicy
   */
  readonly timeoutPolicy?: HttpProxySpecRoutesTimeoutPolicy;

}

/**
 * Converts an object of type 'HttpProxySpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutes(obj: HttpProxySpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_HttpProxySpecRoutesAuthPolicy(obj.authPolicy),
    'conditions': obj.conditions?.map(y => toJson_HttpProxySpecRoutesConditions(y)),
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecRoutesCookieRewritePolicies(y)),
    'directResponsePolicy': toJson_HttpProxySpecRoutesDirectResponsePolicy(obj.directResponsePolicy),
    'enableWebsockets': obj.enableWebsockets,
    'healthCheckPolicy': toJson_HttpProxySpecRoutesHealthCheckPolicy(obj.healthCheckPolicy),
    'internalRedirectPolicy': toJson_HttpProxySpecRoutesInternalRedirectPolicy(obj.internalRedirectPolicy),
    'ipAllowPolicy': obj.ipAllowPolicy?.map(y => toJson_HttpProxySpecRoutesIpAllowPolicy(y)),
    'ipDenyPolicy': obj.ipDenyPolicy?.map(y => toJson_HttpProxySpecRoutesIpDenyPolicy(y)),
    'jwtVerificationPolicy': toJson_HttpProxySpecRoutesJwtVerificationPolicy(obj.jwtVerificationPolicy),
    'loadBalancerPolicy': toJson_HttpProxySpecRoutesLoadBalancerPolicy(obj.loadBalancerPolicy),
    'pathRewritePolicy': toJson_HttpProxySpecRoutesPathRewritePolicy(obj.pathRewritePolicy),
    'permitInsecure': obj.permitInsecure,
    'rateLimitPolicy': toJson_HttpProxySpecRoutesRateLimitPolicy(obj.rateLimitPolicy),
    'requestHeadersPolicy': toJson_HttpProxySpecRoutesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'requestRedirectPolicy': toJson_HttpProxySpecRoutesRequestRedirectPolicy(obj.requestRedirectPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecRoutesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'retryPolicy': toJson_HttpProxySpecRoutesRetryPolicy(obj.retryPolicy),
    'services': obj.services?.map(y => toJson_HttpProxySpecRoutesServices(y)),
    'timeoutPolicy': toJson_HttpProxySpecRoutesTimeoutPolicy(obj.timeoutPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPProxy holds TCP proxy information.
 *
 * @schema HttpProxySpecTcpproxy
 */
export interface HttpProxySpecTcpproxy {
  /**
   * The health check policy for this tcp proxy
   *
   * @schema HttpProxySpecTcpproxy#healthCheckPolicy
   */
  readonly healthCheckPolicy?: HttpProxySpecTcpproxyHealthCheckPolicy;

  /**
   * Include specifies that this tcpproxy should be delegated to another HTTPProxy.
   *
   * @schema HttpProxySpecTcpproxy#include
   */
  readonly include?: HttpProxySpecTcpproxyInclude;

  /**
   * IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
   * Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
   *
   * @schema HttpProxySpecTcpproxy#includes
   */
  readonly includes?: HttpProxySpecTcpproxyIncludes;

  /**
   * The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
   *
   * @schema HttpProxySpecTcpproxy#loadBalancerPolicy
   */
  readonly loadBalancerPolicy?: HttpProxySpecTcpproxyLoadBalancerPolicy;

  /**
   * Services are the services to proxy traffic
   *
   * @schema HttpProxySpecTcpproxy#services
   */
  readonly services?: HttpProxySpecTcpproxyServices[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxy(obj: HttpProxySpecTcpproxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthCheckPolicy': toJson_HttpProxySpecTcpproxyHealthCheckPolicy(obj.healthCheckPolicy),
    'include': toJson_HttpProxySpecTcpproxyInclude(obj.include),
    'includes': toJson_HttpProxySpecTcpproxyIncludes(obj.includes),
    'loadBalancerPolicy': toJson_HttpProxySpecTcpproxyLoadBalancerPolicy(obj.loadBalancerPolicy),
    'services': obj.services?.map(y => toJson_HttpProxySpecTcpproxyServices(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Virtualhost appears at most once. If it is present, the object is considered to be a "root" HTTPProxy.
 *
 * @schema HttpProxySpecVirtualhost
 */
export interface HttpProxySpecVirtualhost {
  /**
   * This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.
   *
   * @schema HttpProxySpecVirtualhost#authorization
   */
  readonly authorization?: HttpProxySpecVirtualhostAuthorization;

  /**
   * Specifies the cross-origin policy to apply to the VirtualHost.
   *
   * @schema HttpProxySpecVirtualhost#corsPolicy
   */
  readonly corsPolicy?: HttpProxySpecVirtualhostCorsPolicy;

  /**
   * The fully qualified domain name of the root of the ingress tree all leaves of the DAG rooted at this object relate to the fqdn.
   *
   * @schema HttpProxySpecVirtualhost#fqdn
   */
  readonly fqdn: string;

  /**
   * IPAllowFilterPolicy is a list of ipv4/6 filter rules for which matching requests should be allowed. All other requests will be denied. Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined. The rules defined here may be overridden in a Route.
   *
   * @schema HttpProxySpecVirtualhost#ipAllowPolicy
   */
  readonly ipAllowPolicy?: HttpProxySpecVirtualhostIpAllowPolicy[];

  /**
   * IPDenyFilterPolicy is a list of ipv4/6 filter rules for which matching requests should be denied. All other requests will be allowed. Only one of IPAllowFilterPolicy and IPDenyFilterPolicy can be defined. The rules defined here may be overridden in a Route.
   *
   * @schema HttpProxySpecVirtualhost#ipDenyPolicy
   */
  readonly ipDenyPolicy?: HttpProxySpecVirtualhostIpDenyPolicy[];

  /**
   * Providers to use for verifying JSON Web Tokens (JWTs) on the virtual host.
   *
   * @schema HttpProxySpecVirtualhost#jwtProviders
   */
  readonly jwtProviders?: HttpProxySpecVirtualhostJwtProviders[];

  /**
   * The policy for rate limiting on the virtual host.
   *
   * @schema HttpProxySpecVirtualhost#rateLimitPolicy
   */
  readonly rateLimitPolicy?: HttpProxySpecVirtualhostRateLimitPolicy;

  /**
   * If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.
   *
   * @schema HttpProxySpecVirtualhost#tls
   */
  readonly tls?: HttpProxySpecVirtualhostTls;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhost(obj: HttpProxySpecVirtualhost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorization': toJson_HttpProxySpecVirtualhostAuthorization(obj.authorization),
    'corsPolicy': toJson_HttpProxySpecVirtualhostCorsPolicy(obj.corsPolicy),
    'fqdn': obj.fqdn,
    'ipAllowPolicy': obj.ipAllowPolicy?.map(y => toJson_HttpProxySpecVirtualhostIpAllowPolicy(y)),
    'ipDenyPolicy': obj.ipDenyPolicy?.map(y => toJson_HttpProxySpecVirtualhostIpDenyPolicy(y)),
    'jwtProviders': obj.jwtProviders?.map(y => toJson_HttpProxySpecVirtualhostJwtProviders(y)),
    'rateLimitPolicy': toJson_HttpProxySpecVirtualhostRateLimitPolicy(obj.rateLimitPolicy),
    'tls': toJson_HttpProxySpecVirtualhostTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix, Exact, Header or QueryParameter must be provided.
 *
 * @schema HttpProxySpecIncludesConditions
 */
export interface HttpProxySpecIncludesConditions {
  /**
   * Exact defines a exact match for a request. This field is not allowed in include match conditions.
   *
   * @schema HttpProxySpecIncludesConditions#exact
   */
  readonly exact?: string;

  /**
   * Header specifies the header condition to match.
   *
   * @schema HttpProxySpecIncludesConditions#header
   */
  readonly header?: HttpProxySpecIncludesConditionsHeader;

  /**
   * Prefix defines a prefix match for a request.
   *
   * @schema HttpProxySpecIncludesConditions#prefix
   */
  readonly prefix?: string;

  /**
   * QueryParameter specifies the query parameter condition to match.
   *
   * @schema HttpProxySpecIncludesConditions#queryParameter
   */
  readonly queryParameter?: HttpProxySpecIncludesConditionsQueryParameter;

}

/**
 * Converts an object of type 'HttpProxySpecIncludesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludesConditions(obj: HttpProxySpecIncludesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'header': toJson_HttpProxySpecIncludesConditionsHeader(obj.header),
    'prefix': obj.prefix,
    'queryParameter': toJson_HttpProxySpecIncludesConditionsQueryParameter(obj.queryParameter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy updates the authorization policy that was set on the root HTTPProxy object for client requests that match this route.
 *
 * @schema HttpProxySpecRoutesAuthPolicy
 */
export interface HttpProxySpecRoutesAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema HttpProxySpecRoutesAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema HttpProxySpecRoutesAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesAuthPolicy(obj: HttpProxySpecRoutesAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchCondition are a general holder for matching rules for HTTPProxies. One of Prefix, Exact, Header or QueryParameter must be provided.
 *
 * @schema HttpProxySpecRoutesConditions
 */
export interface HttpProxySpecRoutesConditions {
  /**
   * Exact defines a exact match for a request. This field is not allowed in include match conditions.
   *
   * @schema HttpProxySpecRoutesConditions#exact
   */
  readonly exact?: string;

  /**
   * Header specifies the header condition to match.
   *
   * @schema HttpProxySpecRoutesConditions#header
   */
  readonly header?: HttpProxySpecRoutesConditionsHeader;

  /**
   * Prefix defines a prefix match for a request.
   *
   * @schema HttpProxySpecRoutesConditions#prefix
   */
  readonly prefix?: string;

  /**
   * QueryParameter specifies the query parameter condition to match.
   *
   * @schema HttpProxySpecRoutesConditions#queryParameter
   */
  readonly queryParameter?: HttpProxySpecRoutesConditionsQueryParameter;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesConditions(obj: HttpProxySpecRoutesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'header': toJson_HttpProxySpecRoutesConditionsHeader(obj.header),
    'prefix': obj.prefix,
    'queryParameter': toJson_HttpProxySpecRoutesConditionsQueryParameter(obj.queryParameter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecRoutesCookieRewritePolicies
 */
export interface HttpProxySpecRoutesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecRoutesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecRoutesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePolicies(obj: HttpProxySpecRoutesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecRoutesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DirectResponsePolicy returns an arbitrary HTTP response directly.
 *
 * @schema HttpProxySpecRoutesDirectResponsePolicy
 */
export interface HttpProxySpecRoutesDirectResponsePolicy {
  /**
   * Body is the content of the response body. If this setting is omitted, no body is included in the generated response.
   * Note: Body is not recommended to set too long otherwise it can have significant resource usage impacts.
   *
   * @schema HttpProxySpecRoutesDirectResponsePolicy#body
   */
  readonly body?: string;

  /**
   * StatusCode is the HTTP response status to be returned.
   *
   * @schema HttpProxySpecRoutesDirectResponsePolicy#statusCode
   */
  readonly statusCode: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesDirectResponsePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesDirectResponsePolicy(obj: HttpProxySpecRoutesDirectResponsePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The health check policy for this route.
 *
 * @schema HttpProxySpecRoutesHealthCheckPolicy
 */
export interface HttpProxySpecRoutesHealthCheckPolicy {
  /**
   * The number of healthy health checks required before a host is marked healthy
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#healthyThresholdCount
   */
  readonly healthyThresholdCount?: number;

  /**
   * The value of the host header in the HTTP health check request. If left empty (default value), the name "contour-envoy-healthcheck" will be used.
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#host
   */
  readonly host?: string;

  /**
   * The interval (seconds) between health checks
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#intervalSeconds
   */
  readonly intervalSeconds?: number;

  /**
   * HTTP endpoint used to perform health checks on upstream service
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#path
   */
  readonly path: string;

  /**
   * The time to wait (seconds) for a health check response
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The number of unhealthy health checks required before a host is marked unhealthy
   *
   * @schema HttpProxySpecRoutesHealthCheckPolicy#unhealthyThresholdCount
   */
  readonly unhealthyThresholdCount?: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesHealthCheckPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesHealthCheckPolicy(obj: HttpProxySpecRoutesHealthCheckPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThresholdCount': obj.healthyThresholdCount,
    'host': obj.host,
    'intervalSeconds': obj.intervalSeconds,
    'path': obj.path,
    'timeoutSeconds': obj.timeoutSeconds,
    'unhealthyThresholdCount': obj.unhealthyThresholdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy to define when to handle redirects responses internally.
 *
 * @schema HttpProxySpecRoutesInternalRedirectPolicy
 */
export interface HttpProxySpecRoutesInternalRedirectPolicy {
  /**
   * AllowCrossSchemeRedirect Allow internal redirect to follow a target URI with a different scheme than the value of x-forwarded-proto. SafeOnly allows same scheme redirect and safe cross scheme redirect, which means if the downstream scheme is HTTPS, both HTTPS and HTTP redirect targets are allowed, but if the downstream scheme is HTTP, only HTTP redirect targets are allowed.
   *
   * @schema HttpProxySpecRoutesInternalRedirectPolicy#allowCrossSchemeRedirect
   */
  readonly allowCrossSchemeRedirect?: HttpProxySpecRoutesInternalRedirectPolicyAllowCrossSchemeRedirect;

  /**
   * If DenyRepeatedRouteRedirect is true, rejects redirect targets that are pointing to a route that has been followed by a previous redirect from the current route.
   *
   * @schema HttpProxySpecRoutesInternalRedirectPolicy#denyRepeatedRouteRedirect
   */
  readonly denyRepeatedRouteRedirect?: boolean;

  /**
   * MaxInternalRedirects An internal redirect is not handled, unless the number of previous internal redirects that a downstream request has encountered is lower than this value.
   *
   * @schema HttpProxySpecRoutesInternalRedirectPolicy#maxInternalRedirects
   */
  readonly maxInternalRedirects?: number;

  /**
   * RedirectResponseCodes If unspecified, only 302 will be treated as internal redirect. Only 301, 302, 303, 307 and 308 are valid values.
   *
   * @schema HttpProxySpecRoutesInternalRedirectPolicy#redirectResponseCodes
   */
  readonly redirectResponseCodes?: HttpProxySpecRoutesInternalRedirectPolicyRedirectResponseCodes[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesInternalRedirectPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesInternalRedirectPolicy(obj: HttpProxySpecRoutesInternalRedirectPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCrossSchemeRedirect': obj.allowCrossSchemeRedirect,
    'denyRepeatedRouteRedirect': obj.denyRepeatedRouteRedirect,
    'maxInternalRedirects': obj.maxInternalRedirects,
    'redirectResponseCodes': obj.redirectResponseCodes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecRoutesIpAllowPolicy
 */
export interface HttpProxySpecRoutesIpAllowPolicy {
  /**
   * CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be a bare IP address (without a mask) to filter on exactly one address.
   *
   * @schema HttpProxySpecRoutesIpAllowPolicy#cidr
   */
  readonly cidr: string;

  /**
   * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
   *
   * @schema HttpProxySpecRoutesIpAllowPolicy#source
   */
  readonly source: HttpProxySpecRoutesIpAllowPolicySource;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesIpAllowPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesIpAllowPolicy(obj: HttpProxySpecRoutesIpAllowPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecRoutesIpDenyPolicy
 */
export interface HttpProxySpecRoutesIpDenyPolicy {
  /**
   * CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be a bare IP address (without a mask) to filter on exactly one address.
   *
   * @schema HttpProxySpecRoutesIpDenyPolicy#cidr
   */
  readonly cidr: string;

  /**
   * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
   *
   * @schema HttpProxySpecRoutesIpDenyPolicy#source
   */
  readonly source: HttpProxySpecRoutesIpDenyPolicySource;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesIpDenyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesIpDenyPolicy(obj: HttpProxySpecRoutesIpDenyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for verifying JWTs for requests to this route.
 *
 * @schema HttpProxySpecRoutesJwtVerificationPolicy
 */
export interface HttpProxySpecRoutesJwtVerificationPolicy {
  /**
   * Disabled defines whether to disable all JWT verification for this route. This can be used to opt specific routes out of the default JWT provider for the HTTPProxy. At most one of this field or the "require" field can be specified.
   *
   * @schema HttpProxySpecRoutesJwtVerificationPolicy#disabled
   */
  readonly disabled?: boolean;

  /**
   * Require names a specific JWT provider (defined in the virtual host) to require for the route. If specified, this field overrides the default provider if one exists. If this field is not specified, the default provider will be required if one exists. At most one of this field or the "disabled" field can be specified.
   *
   * @schema HttpProxySpecRoutesJwtVerificationPolicy#require
   */
  readonly require?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesJwtVerificationPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesJwtVerificationPolicy(obj: HttpProxySpecRoutesJwtVerificationPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'require': obj.require,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The load balancing policy for this route.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicy
 */
export interface HttpProxySpecRoutesLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back to the default `RoundRobin`.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicy(obj: HttpProxySpecRoutesLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rewriting the path of the request URL after the request has been routed to a Service.
 *
 * @schema HttpProxySpecRoutesPathRewritePolicy
 */
export interface HttpProxySpecRoutesPathRewritePolicy {
  /**
   * ReplacePrefix describes how the path prefix should be replaced.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicy#replacePrefix
   */
  readonly replacePrefix?: HttpProxySpecRoutesPathRewritePolicyReplacePrefix[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesPathRewritePolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesPathRewritePolicy(obj: HttpProxySpecRoutesPathRewritePolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'replacePrefix': obj.replacePrefix?.map(y => toJson_HttpProxySpecRoutesPathRewritePolicyReplacePrefix(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rate limiting on the route.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicy
 */
export interface HttpProxySpecRoutesRateLimitPolicy {
  /**
   * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicy#global
   */
  readonly global?: HttpProxySpecRoutesRateLimitPolicyGlobal;

  /**
   * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicy#local
   */
  readonly local?: HttpProxySpecRoutesRateLimitPolicyLocal;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicy(obj: HttpProxySpecRoutesRateLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_HttpProxySpecRoutesRateLimitPolicyGlobal(obj.global),
    'local': toJson_HttpProxySpecRoutesRateLimitPolicyLocal(obj.local),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing request headers during proxying.
 *
 * @schema HttpProxySpecRoutesRequestHeadersPolicy
 */
export interface HttpProxySpecRoutesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestHeadersPolicy(obj: HttpProxySpecRoutesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestRedirectPolicy defines an HTTP redirection.
 *
 * @schema HttpProxySpecRoutesRequestRedirectPolicy
 */
export interface HttpProxySpecRoutesRequestRedirectPolicy {
  /**
   * Hostname is the precise hostname to be used in the value of the `Location` header in the response. When empty, the hostname of the request is used. No wildcards are allowed.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#hostname
   */
  readonly hostname?: string;

  /**
   * Path allows for redirection to a different path from the original on the request. The path must start with a leading slash.
   * Note: Only one of Path or Prefix can be defined.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#path
   */
  readonly path?: string;

  /**
   * Port is the port to be used in the value of the `Location` header in the response. When empty, port (if specified) of the request is used.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#port
   */
  readonly port?: number;

  /**
   * Prefix defines the value to swap the matched prefix or path with. The prefix must start with a leading slash.
   * Note: Only one of Path or Prefix can be defined.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#prefix
   */
  readonly prefix?: string;

  /**
   * Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#scheme
   */
  readonly scheme?: HttpProxySpecRoutesRequestRedirectPolicyScheme;

  /**
   * StatusCode is the HTTP status code to be used in response.
   *
   * @schema HttpProxySpecRoutesRequestRedirectPolicy#statusCode
   */
  readonly statusCode?: HttpProxySpecRoutesRequestRedirectPolicyStatusCode;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestRedirectPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestRedirectPolicy(obj: HttpProxySpecRoutesRequestRedirectPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostname': obj.hostname,
    'path': obj.path,
    'port': obj.port,
    'prefix': obj.prefix,
    'scheme': obj.scheme,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecRoutesResponseHeadersPolicy
 */
export interface HttpProxySpecRoutesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesResponseHeadersPolicy(obj: HttpProxySpecRoutesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The retry policy for this route.
 *
 * @schema HttpProxySpecRoutesRetryPolicy
 */
export interface HttpProxySpecRoutesRetryPolicy {
  /**
   * NumRetries is maximum allowed number of retries. If set to -1, then retries are disabled. If set to 0 or not supplied, the value is set to the Envoy default of 1.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#count
   */
  readonly count?: number;

  /**
   * PerTryTimeout specifies the timeout per retry attempt. Ignored if NumRetries is not supplied.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * RetriableStatusCodes specifies the HTTP status codes that should be retried.
   * This field is only respected when you include `retriable-status-codes` in the `RetryOn` field.
   *
   * @schema HttpProxySpecRoutesRetryPolicy#retriableStatusCodes
   */
  readonly retriableStatusCodes?: number[];

  /**
   * RetryOn specifies the conditions on which to retry a request.
   * Supported [HTTP conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on):
   * - `5xx` - `gateway-error` - `reset` - `connect-failure` - `retriable-4xx` - `refused-stream` - `retriable-status-codes` - `retriable-headers`
   * Supported [gRPC conditions](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on):
   * - `cancelled` - `deadline-exceeded` - `internal` - `resource-exhausted` - `unavailable`
   *
   * @schema HttpProxySpecRoutesRetryPolicy#retryOn
   */
  readonly retryOn?: HttpProxySpecRoutesRetryPolicyRetryOn[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRetryPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRetryPolicy(obj: HttpProxySpecRoutesRetryPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'perTryTimeout': obj.perTryTimeout,
    'retriableStatusCodes': obj.retriableStatusCodes?.map(y => y),
    'retryOn': obj.retryOn?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an Kubernetes Service to proxy traffic.
 *
 * @schema HttpProxySpecRoutesServices
 */
export interface HttpProxySpecRoutesServices {
  /**
   * The policies for rewriting Set-Cookie header attributes.
   *
   * @schema HttpProxySpecRoutesServices#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecRoutesServicesCookieRewritePolicies[];

  /**
   * HealthPort is the port for this service healthcheck. If not specified, Port is used for service healthchecks.
   *
   * @schema HttpProxySpecRoutesServices#healthPort
   */
  readonly healthPort?: number;

  /**
   * If Mirror is true the Service will receive a read only mirror of the traffic for this route.
   *
   * @schema HttpProxySpecRoutesServices#mirror
   */
  readonly mirror?: boolean;

  /**
   * Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.
   *
   * @schema HttpProxySpecRoutesServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema HttpProxySpecRoutesServices#port
   */
  readonly port: number;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema HttpProxySpecRoutesServices#protocol
   */
  readonly protocol?: HttpProxySpecRoutesServicesProtocol;

  /**
   * The policy for managing request headers during proxying.
   *
   * @schema HttpProxySpecRoutesServices#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecRoutesServicesRequestHeadersPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecRoutesServices#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecRoutesServicesResponseHeadersPolicy;

  /**
   * Slow start will gradually increase amount of traffic to a newly added endpoint.
   *
   * @schema HttpProxySpecRoutesServices#slowStartPolicy
   */
  readonly slowStartPolicy?: HttpProxySpecRoutesServicesSlowStartPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema HttpProxySpecRoutesServices#validation
   */
  readonly validation?: HttpProxySpecRoutesServicesValidation;

  /**
   * Weight defines percentage of traffic to balance traffic
   *
   * @schema HttpProxySpecRoutesServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServices(obj: HttpProxySpecRoutesServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecRoutesServicesCookieRewritePolicies(y)),
    'healthPort': obj.healthPort,
    'mirror': obj.mirror,
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'requestHeadersPolicy': toJson_HttpProxySpecRoutesServicesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecRoutesServicesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'slowStartPolicy': toJson_HttpProxySpecRoutesServicesSlowStartPolicy(obj.slowStartPolicy),
    'validation': toJson_HttpProxySpecRoutesServicesValidation(obj.validation),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The timeout policy for this route.
 *
 * @schema HttpProxySpecRoutesTimeoutPolicy
 */
export interface HttpProxySpecRoutesTimeoutPolicy {
  /**
   * Timeout for how long the proxy should wait while there is no activity during single request/response (for HTTP/1.1) or stream (for HTTP/2). Timeout will not trigger while HTTP/1.1 connection is idle between two consecutive requests. If not specified, there is no per-route idle timeout, though a connection manager-wide stream_idle_timeout default of 5m still applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#idle
   */
  readonly idle?: string;

  /**
   * Timeout for how long connection from the proxy to the upstream service is kept when there are no active requests. If not supplied, Envoy's default value of 1h applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#idleConnection
   */
  readonly idleConnection?: string;

  /**
   * Timeout for receiving a response from the server after processing a request from client. If not supplied, Envoy's default value of 15s applies.
   *
   * @schema HttpProxySpecRoutesTimeoutPolicy#response
   */
  readonly response?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesTimeoutPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesTimeoutPolicy(obj: HttpProxySpecRoutesTimeoutPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idle': obj.idle,
    'idleConnection': obj.idleConnection,
    'response': obj.response,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The health check policy for this tcp proxy
 *
 * @schema HttpProxySpecTcpproxyHealthCheckPolicy
 */
export interface HttpProxySpecTcpproxyHealthCheckPolicy {
  /**
   * The number of healthy health checks required before a host is marked healthy
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#healthyThresholdCount
   */
  readonly healthyThresholdCount?: number;

  /**
   * The interval (seconds) between health checks
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#intervalSeconds
   */
  readonly intervalSeconds?: number;

  /**
   * The time to wait (seconds) for a health check response
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

  /**
   * The number of unhealthy health checks required before a host is marked unhealthy
   *
   * @schema HttpProxySpecTcpproxyHealthCheckPolicy#unhealthyThresholdCount
   */
  readonly unhealthyThresholdCount?: number;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyHealthCheckPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyHealthCheckPolicy(obj: HttpProxySpecTcpproxyHealthCheckPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'healthyThresholdCount': obj.healthyThresholdCount,
    'intervalSeconds': obj.intervalSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
    'unhealthyThresholdCount': obj.unhealthyThresholdCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Include specifies that this tcpproxy should be delegated to another HTTPProxy.
 *
 * @schema HttpProxySpecTcpproxyInclude
 */
export interface HttpProxySpecTcpproxyInclude {
  /**
   * Name of the child HTTPProxy
   *
   * @schema HttpProxySpecTcpproxyInclude#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecTcpproxyInclude#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyInclude(obj: HttpProxySpecTcpproxyInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IncludesDeprecated allow for specific routing configuration to be appended to another HTTPProxy in another namespace.
 * Exists due to a mistake when developing HTTPProxy and the field was marked plural when it should have been singular. This field should stay to not break backwards compatibility to v1 users.
 *
 * @schema HttpProxySpecTcpproxyIncludes
 */
export interface HttpProxySpecTcpproxyIncludes {
  /**
   * Name of the child HTTPProxy
   *
   * @schema HttpProxySpecTcpproxyIncludes#name
   */
  readonly name: string;

  /**
   * Namespace of the HTTPProxy to include. Defaults to the current namespace if not supplied.
   *
   * @default the current namespace if not supplied.
   * @schema HttpProxySpecTcpproxyIncludes#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyIncludes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyIncludes(obj: HttpProxySpecTcpproxyIncludes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The load balancing policy for the backend services. Note that the `Cookie` and `RequestHash` load balancing strategies cannot be used here.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicy
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicy {
  /**
   * RequestHashPolicies contains a list of hash policies to apply when the `RequestHash` load balancing strategy is chosen. If an element of the supplied list of hash policies is invalid, it will be ignored. If the list of hash policies is empty after validation, the load balancing strategy will fall back to the default `RoundRobin`.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicy#requestHashPolicies
   */
  readonly requestHashPolicies?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies[];

  /**
   * Strategy specifies the policy used to balance requests across the pool of backend pods. Valid policy names are `Random`, `RoundRobin`, `WeightedLeastRequest`, `Cookie`, and `RequestHash`. If an unknown strategy name is specified or no policy is supplied, the default `RoundRobin` policy is used.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicy#strategy
   */
  readonly strategy?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicy(obj: HttpProxySpecTcpproxyLoadBalancerPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHashPolicies': obj.requestHashPolicies?.map(y => toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies(y)),
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an Kubernetes Service to proxy traffic.
 *
 * @schema HttpProxySpecTcpproxyServices
 */
export interface HttpProxySpecTcpproxyServices {
  /**
   * The policies for rewriting Set-Cookie header attributes.
   *
   * @schema HttpProxySpecTcpproxyServices#cookieRewritePolicies
   */
  readonly cookieRewritePolicies?: HttpProxySpecTcpproxyServicesCookieRewritePolicies[];

  /**
   * HealthPort is the port for this service healthcheck. If not specified, Port is used for service healthchecks.
   *
   * @schema HttpProxySpecTcpproxyServices#healthPort
   */
  readonly healthPort?: number;

  /**
   * If Mirror is true the Service will receive a read only mirror of the traffic for this route.
   *
   * @schema HttpProxySpecTcpproxyServices#mirror
   */
  readonly mirror?: boolean;

  /**
   * Name is the name of Kubernetes service to proxy traffic. Names defined here will be used to look up corresponding endpoints which contain the ips to route.
   *
   * @schema HttpProxySpecTcpproxyServices#name
   */
  readonly name: string;

  /**
   * Port (defined as Integer) to proxy traffic to since a service can have multiple defined.
   *
   * @schema HttpProxySpecTcpproxyServices#port
   */
  readonly port: number;

  /**
   * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
   *
   * @schema HttpProxySpecTcpproxyServices#protocol
   */
  readonly protocol?: HttpProxySpecTcpproxyServicesProtocol;

  /**
   * The policy for managing request headers during proxying.
   *
   * @schema HttpProxySpecTcpproxyServices#requestHeadersPolicy
   */
  readonly requestHeadersPolicy?: HttpProxySpecTcpproxyServicesRequestHeadersPolicy;

  /**
   * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
   *
   * @schema HttpProxySpecTcpproxyServices#responseHeadersPolicy
   */
  readonly responseHeadersPolicy?: HttpProxySpecTcpproxyServicesResponseHeadersPolicy;

  /**
   * Slow start will gradually increase amount of traffic to a newly added endpoint.
   *
   * @schema HttpProxySpecTcpproxyServices#slowStartPolicy
   */
  readonly slowStartPolicy?: HttpProxySpecTcpproxyServicesSlowStartPolicy;

  /**
   * UpstreamValidation defines how to verify the backend service's certificate
   *
   * @schema HttpProxySpecTcpproxyServices#validation
   */
  readonly validation?: HttpProxySpecTcpproxyServicesValidation;

  /**
   * Weight defines percentage of traffic to balance traffic
   *
   * @schema HttpProxySpecTcpproxyServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServices(obj: HttpProxySpecTcpproxyServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieRewritePolicies': obj.cookieRewritePolicies?.map(y => toJson_HttpProxySpecTcpproxyServicesCookieRewritePolicies(y)),
    'healthPort': obj.healthPort,
    'mirror': obj.mirror,
    'name': obj.name,
    'port': obj.port,
    'protocol': obj.protocol,
    'requestHeadersPolicy': toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicy(obj.requestHeadersPolicy),
    'responseHeadersPolicy': toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicy(obj.responseHeadersPolicy),
    'slowStartPolicy': toJson_HttpProxySpecTcpproxyServicesSlowStartPolicy(obj.slowStartPolicy),
    'validation': toJson_HttpProxySpecTcpproxyServicesValidation(obj.validation),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * This field configures an extension service to perform authorization for this virtual host. Authorization can only be configured on virtual hosts that have TLS enabled. If the TLS configuration requires client certificate validation, the client certificate is always included in the authentication check request.
 *
 * @schema HttpProxySpecVirtualhostAuthorization
 */
export interface HttpProxySpecVirtualhostAuthorization {
  /**
   * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#authPolicy
   */
  readonly authPolicy?: HttpProxySpecVirtualhostAuthorizationAuthPolicy;

  /**
   * ExtensionServiceRef specifies the extension resource that will authorize client requests.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#extensionRef
   */
  readonly extensionRef?: HttpProxySpecVirtualhostAuthorizationExtensionRef;

  /**
   * If FailOpen is true, the client request is forwarded to the upstream service even if the authorization server fails to respond. This field should not be set in most cases. It is intended for use only while migrating applications from internal authorization to Contour external authorization.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#failOpen
   */
  readonly failOpen?: boolean;

  /**
   * ResponseTimeout configures maximum time to wait for a check response from the authorization server. Timeout durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". The string "infinity" is also a valid input and specifies no timeout.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#responseTimeout
   */
  readonly responseTimeout?: string;

  /**
   * WithRequestBody specifies configuration for sending the client request's body to authorization server.
   *
   * @schema HttpProxySpecVirtualhostAuthorization#withRequestBody
   */
  readonly withRequestBody?: HttpProxySpecVirtualhostAuthorizationWithRequestBody;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorization' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorization(obj: HttpProxySpecVirtualhostAuthorization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPolicy': toJson_HttpProxySpecVirtualhostAuthorizationAuthPolicy(obj.authPolicy),
    'extensionRef': toJson_HttpProxySpecVirtualhostAuthorizationExtensionRef(obj.extensionRef),
    'failOpen': obj.failOpen,
    'responseTimeout': obj.responseTimeout,
    'withRequestBody': toJson_HttpProxySpecVirtualhostAuthorizationWithRequestBody(obj.withRequestBody),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the cross-origin policy to apply to the VirtualHost.
 *
 * @schema HttpProxySpecVirtualhostCorsPolicy
 */
export interface HttpProxySpecVirtualhostCorsPolicy {
  /**
   * Specifies whether the resource allows credentials.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * AllowHeaders specifies the content for the *access-control-allow-headers* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * AllowMethods specifies the content for the *access-control-allow-methods* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowMethods
   */
  readonly allowMethods: string[];

  /**
   * AllowOrigin specifies the origins that will be allowed to do CORS requests. Allowed values include "*" which signifies any origin is allowed, an exact origin of the form "scheme://host[:port]" (where port is optional), or a valid regex pattern. Note that regex patterns are validated and a simple "glob" pattern (e.g. *.foo.com) will be rejected or produce unexpected matches when applied as a regex.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowOrigin
   */
  readonly allowOrigin: string[];

  /**
   * AllowPrivateNetwork specifies whether to allow private network requests. See https://developer.chrome.com/blog/private-network-access-preflight.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#allowPrivateNetwork
   */
  readonly allowPrivateNetwork?: boolean;

  /**
   * ExposeHeaders Specifies the content for the *access-control-expose-headers* header.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * MaxAge indicates for how long the results of a preflight request can be cached. MaxAge durations are expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". Only positive values are allowed while 0 disables the cache requiring a preflight OPTIONS check for all cross-origin requests.
   *
   * @schema HttpProxySpecVirtualhostCorsPolicy#maxAge
   */
  readonly maxAge?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostCorsPolicy(obj: HttpProxySpecVirtualhostCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowPrivateNetwork': obj.allowPrivateNetwork,
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecVirtualhostIpAllowPolicy
 */
export interface HttpProxySpecVirtualhostIpAllowPolicy {
  /**
   * CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be a bare IP address (without a mask) to filter on exactly one address.
   *
   * @schema HttpProxySpecVirtualhostIpAllowPolicy#cidr
   */
  readonly cidr: string;

  /**
   * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
   *
   * @schema HttpProxySpecVirtualhostIpAllowPolicy#source
   */
  readonly source: HttpProxySpecVirtualhostIpAllowPolicySource;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostIpAllowPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostIpAllowPolicy(obj: HttpProxySpecVirtualhostIpAllowPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecVirtualhostIpDenyPolicy
 */
export interface HttpProxySpecVirtualhostIpDenyPolicy {
  /**
   * CIDR is a CIDR block of ipv4 or ipv6 addresses to filter on. This can also be a bare IP address (without a mask) to filter on exactly one address.
   *
   * @schema HttpProxySpecVirtualhostIpDenyPolicy#cidr
   */
  readonly cidr: string;

  /**
   * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
   *
   * @schema HttpProxySpecVirtualhostIpDenyPolicy#source
   */
  readonly source: HttpProxySpecVirtualhostIpDenyPolicySource;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostIpDenyPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostIpDenyPolicy(obj: HttpProxySpecVirtualhostIpDenyPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cidr': obj.cidr,
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JWTProvider defines how to verify JWTs on requests.
 *
 * @schema HttpProxySpecVirtualhostJwtProviders
 */
export interface HttpProxySpecVirtualhostJwtProviders {
  /**
   * Audiences that JWTs are allowed to have in the "aud" field. If not provided, JWT audiences are not checked.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#audiences
   */
  readonly audiences?: string[];

  /**
   * Whether the provider should apply to all routes in the HTTPProxy/its includes by default. At most one provider can be marked as the default. If no provider is marked as the default, individual routes must explicitly identify the provider they require.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#default
   */
  readonly default?: boolean;

  /**
   * Whether the JWT should be forwarded to the backend service after successful verification. By default, the JWT is not forwarded.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#forwardJWT
   */
  readonly forwardJwt?: boolean;

  /**
   * Issuer that JWTs are required to have in the "iss" field. If not provided, JWT issuers are not checked.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#issuer
   */
  readonly issuer?: string;

  /**
   * Unique name for the provider.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#name
   */
  readonly name: string;

  /**
   * Remote JWKS to use for verifying JWT signatures.
   *
   * @schema HttpProxySpecVirtualhostJwtProviders#remoteJWKS
   */
  readonly remoteJwks: HttpProxySpecVirtualhostJwtProvidersRemoteJwks;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostJwtProviders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostJwtProviders(obj: HttpProxySpecVirtualhostJwtProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'default': obj.default,
    'forwardJWT': obj.forwardJwt,
    'issuer': obj.issuer,
    'name': obj.name,
    'remoteJWKS': toJson_HttpProxySpecVirtualhostJwtProvidersRemoteJwks(obj.remoteJwks),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for rate limiting on the virtual host.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicy
 */
export interface HttpProxySpecVirtualhostRateLimitPolicy {
  /**
   * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicy#global
   */
  readonly global?: HttpProxySpecVirtualhostRateLimitPolicyGlobal;

  /**
   * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicy#local
   */
  readonly local?: HttpProxySpecVirtualhostRateLimitPolicyLocal;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicy(obj: HttpProxySpecVirtualhostRateLimitPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'global': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobal(obj.global),
    'local': toJson_HttpProxySpecVirtualhostRateLimitPolicyLocal(obj.local),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If present the fields describes TLS properties of the virtual host. The SNI names that will be matched on are described in fqdn, the tls.secretName secret must contain a certificate that itself contains a name that matches the FQDN.
 *
 * @schema HttpProxySpecVirtualhostTls
 */
export interface HttpProxySpecVirtualhostTls {
  /**
   * ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy.
   * This setting:
   * 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e. validation required or skipped).
   * Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.
   *
   * @schema HttpProxySpecVirtualhostTls#clientValidation
   */
  readonly clientValidation?: HttpProxySpecVirtualhostTlsClientValidation;

  /**
   * EnableFallbackCertificate defines if the vhost should allow a default certificate to be applied which handles all requests which don't match the SNI defined in this vhost.
   *
   * @schema HttpProxySpecVirtualhostTls#enableFallbackCertificate
   */
  readonly enableFallbackCertificate?: boolean;

  /**
   * MinimumProtocolVersion is the minimum TLS version this vhost should negotiate. Valid options are `1.2` (default) and `1.3`. Any other value defaults to TLS 1.2.
   *
   * @schema HttpProxySpecVirtualhostTls#minimumProtocolVersion
   */
  readonly minimumProtocolVersion?: string;

  /**
   * Passthrough defines whether the encrypted TLS handshake will be passed through to the backing cluster. Either Passthrough or SecretName must be specified, but not both.
   *
   * @schema HttpProxySpecVirtualhostTls#passthrough
   */
  readonly passthrough?: boolean;

  /**
   * SecretName is the name of a TLS secret in the current namespace. Either SecretName or Passthrough must be specified, but not both. If specified, the named secret must contain a matching certificate for the virtual host's FQDN.
   *
   * @schema HttpProxySpecVirtualhostTls#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostTls(obj: HttpProxySpecVirtualhostTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientValidation': toJson_HttpProxySpecVirtualhostTlsClientValidation(obj.clientValidation),
    'enableFallbackCertificate': obj.enableFallbackCertificate,
    'minimumProtocolVersion': obj.minimumProtocolVersion,
    'passthrough': obj.passthrough,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header specifies the header condition to match.
 *
 * @schema HttpProxySpecIncludesConditionsHeader
 */
export interface HttpProxySpecIncludesConditionsHeader {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecIncludesConditionsHeader#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecIncludesConditionsHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludesConditionsHeader(obj: HttpProxySpecIncludesConditionsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameter specifies the query parameter condition to match.
 *
 * @schema HttpProxySpecIncludesConditionsQueryParameter
 */
export interface HttpProxySpecIncludesConditionsQueryParameter {
  /**
   * Contains specifies a substring that must be present in the query parameter value.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the query parameter value must be equal to.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#exact
   */
  readonly exact?: string;

  /**
   * IgnoreCase specifies that string matching should be case insensitive. Note that this has no effect on the Regex parameter.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#ignoreCase
   */
  readonly ignoreCase?: boolean;

  /**
   * Name is the name of the query parameter to match against. Name is required. Query parameter names are case insensitive.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#name
   */
  readonly name: string;

  /**
   * Prefix defines a prefix match for the query parameter value.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#prefix
   */
  readonly prefix?: string;

  /**
   * Present specifies that condition is true when the named query parameter is present, regardless of its value. Note that setting Present to false does not make the condition true if the named query parameter is absent.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#present
   */
  readonly present?: boolean;

  /**
   * Regex specifies a regular expression pattern that must match the query parameter value.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#regex
   */
  readonly regex?: string;

  /**
   * Suffix defines a suffix match for a query parameter value.
   *
   * @schema HttpProxySpecIncludesConditionsQueryParameter#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'HttpProxySpecIncludesConditionsQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecIncludesConditionsQueryParameter(obj: HttpProxySpecIncludesConditionsQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'ignoreCase': obj.ignoreCase,
    'name': obj.name,
    'prefix': obj.prefix,
    'present': obj.present,
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header specifies the header condition to match.
 *
 * @schema HttpProxySpecRoutesConditionsHeader
 */
export interface HttpProxySpecRoutesConditionsHeader {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecRoutesConditionsHeader#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesConditionsHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesConditionsHeader(obj: HttpProxySpecRoutesConditionsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameter specifies the query parameter condition to match.
 *
 * @schema HttpProxySpecRoutesConditionsQueryParameter
 */
export interface HttpProxySpecRoutesConditionsQueryParameter {
  /**
   * Contains specifies a substring that must be present in the query parameter value.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the query parameter value must be equal to.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#exact
   */
  readonly exact?: string;

  /**
   * IgnoreCase specifies that string matching should be case insensitive. Note that this has no effect on the Regex parameter.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#ignoreCase
   */
  readonly ignoreCase?: boolean;

  /**
   * Name is the name of the query parameter to match against. Name is required. Query parameter names are case insensitive.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#name
   */
  readonly name: string;

  /**
   * Prefix defines a prefix match for the query parameter value.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#prefix
   */
  readonly prefix?: string;

  /**
   * Present specifies that condition is true when the named query parameter is present, regardless of its value. Note that setting Present to false does not make the condition true if the named query parameter is absent.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#present
   */
  readonly present?: boolean;

  /**
   * Regex specifies a regular expression pattern that must match the query parameter value.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#regex
   */
  readonly regex?: string;

  /**
   * Suffix defines a suffix match for a query parameter value.
   *
   * @schema HttpProxySpecRoutesConditionsQueryParameter#suffix
   */
  readonly suffix?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesConditionsQueryParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesConditionsQueryParameter(obj: HttpProxySpecRoutesConditionsQueryParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'ignoreCase': obj.ignoreCase,
    'name': obj.name,
    'prefix': obj.prefix,
    'present': obj.present,
    'regex': obj.regex,
    'suffix': obj.suffix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecRoutesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecRoutesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecRoutesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecRoutesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecRoutesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = "Strict",
  /** Lax */
  LAX = "Lax",
  /** None */
  NONE = "None",
}

/**
 * AllowCrossSchemeRedirect Allow internal redirect to follow a target URI with a different scheme than the value of x-forwarded-proto. SafeOnly allows same scheme redirect and safe cross scheme redirect, which means if the downstream scheme is HTTPS, both HTTPS and HTTP redirect targets are allowed, but if the downstream scheme is HTTP, only HTTP redirect targets are allowed.
 *
 * @schema HttpProxySpecRoutesInternalRedirectPolicyAllowCrossSchemeRedirect
 */
export enum HttpProxySpecRoutesInternalRedirectPolicyAllowCrossSchemeRedirect {
  /** Always */
  ALWAYS = "Always",
  /** Never */
  NEVER = "Never",
  /** SafeOnly */
  SAFE_ONLY = "SafeOnly",
}

/**
 * RedirectResponseCode is a uint32 type alias with validation to ensure that the value is valid.
 *
 * @schema HttpProxySpecRoutesInternalRedirectPolicyRedirectResponseCodes
 */
export enum HttpProxySpecRoutesInternalRedirectPolicyRedirectResponseCodes {
  /** 301 */
  VALUE_301 = 301,
  /** 302 */
  VALUE_302 = 302,
  /** 303 */
  VALUE_303 = 303,
  /** 307 */
  VALUE_307 = 307,
  /** 308 */
  VALUE_308 = 308,
}

/**
 * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
 *
 * @schema HttpProxySpecRoutesIpAllowPolicySource
 */
export enum HttpProxySpecRoutesIpAllowPolicySource {
  /** Peer */
  PEER = "Peer",
  /** Remote */
  REMOTE = "Remote",
}

/**
 * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
 *
 * @schema HttpProxySpecRoutesIpDenyPolicySource
 */
export enum HttpProxySpecRoutesIpDenyPolicySource {
  /** Peer */
  PEER = "Peer",
  /** Remote */
  REMOTE = "Remote",
}

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplacePrefix describes a path prefix replacement.
 *
 * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix
 */
export interface HttpProxySpecRoutesPathRewritePolicyReplacePrefix {
  /**
   * Prefix specifies the URL path prefix to be replaced.
   * If Prefix is specified, it must exactly match the MatchCondition prefix that is rendered by the chain of including HTTPProxies and only that path prefix will be replaced by Replacement. This allows HTTPProxies that are included through multiple roots to only replace specific path prefixes, leaving others unmodified.
   * If Prefix is not specified, all routing prefixes rendered by the include chain will be replaced.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix#prefix
   */
  readonly prefix?: string;

  /**
   * Replacement is the string that the routing path prefix will be replaced with. This must not be empty.
   *
   * @schema HttpProxySpecRoutesPathRewritePolicyReplacePrefix#replacement
   */
  readonly replacement: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesPathRewritePolicyReplacePrefix' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesPathRewritePolicyReplacePrefix(obj: HttpProxySpecRoutesPathRewritePolicyReplacePrefix | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prefix': obj.prefix,
    'replacement': obj.replacement,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobal
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobal {
  /**
   * Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobal#descriptors
   */
  readonly descriptors?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobal(obj: HttpProxySpecRoutesRateLimitPolicyGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptors': obj.descriptors?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocal
 */
export interface HttpProxySpecRoutesRateLimitPolicyLocal {
  /**
   * Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#burst
   */
  readonly burst?: number;

  /**
   * Requests defines how many requests per unit of time should be allowed before rate limiting occurs.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#requests
   */
  readonly requests: number;

  /**
   * ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd[];

  /**
   * ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#responseStatusCode
   */
  readonly responseStatusCode?: number;

  /**
   * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocal#unit
   */
  readonly unit: HttpProxySpecRoutesRateLimitPolicyLocalUnit;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyLocal(obj: HttpProxySpecRoutesRateLimitPolicyLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'requests': obj.requests,
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd(y)),
    'responseStatusCode': obj.responseStatusCode,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesRequestHeadersPolicySet
 */
export interface HttpProxySpecRoutesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRequestHeadersPolicySet(obj: HttpProxySpecRoutesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.
 *
 * @schema HttpProxySpecRoutesRequestRedirectPolicyScheme
 */
export enum HttpProxySpecRoutesRequestRedirectPolicyScheme {
  /** http */
  HTTP = "http",
  /** https */
  HTTPS = "https",
}

/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * @schema HttpProxySpecRoutesRequestRedirectPolicyStatusCode
 */
export enum HttpProxySpecRoutesRequestRedirectPolicyStatusCode {
  /** 301 */
  VALUE_301 = 301,
  /** 302 */
  VALUE_302 = 302,
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesResponseHeadersPolicySet
 */
export interface HttpProxySpecRoutesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesResponseHeadersPolicySet(obj: HttpProxySpecRoutesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RetryOn is a string type alias with validation to ensure that the value is valid.
 *
 * @schema HttpProxySpecRoutesRetryPolicyRetryOn
 */
export enum HttpProxySpecRoutesRetryPolicyRetryOn {
  /** 5xx */
  VALUE_5XX = "5xx",
  /** gateway-error */
  GATEWAY_ERROR = "gateway-error",
  /** reset */
  RESET = "reset",
  /** connect-failure */
  CONNECT_FAILURE = "connect-failure",
  /** retriable-4xx */
  RETRIABLE_4XX = "retriable-4xx",
  /** refused-stream */
  REFUSED_STREAM = "refused-stream",
  /** retriable-status-codes */
  RETRIABLE_STATUS_CODES = "retriable-status-codes",
  /** retriable-headers */
  RETRIABLE_HEADERS = "retriable-headers",
  /** cancelled */
  CANCELLED = "cancelled",
  /** deadline-exceeded */
  DEADLINE_EXCEEDED = "deadline-exceeded",
  /** internal */
  INTERNAL = "internal",
  /** resource-exhausted */
  RESOURCE_EXHAUSTED = "resource-exhausted",
  /** unavailable */
  UNAVAILABLE = "unavailable",
}

/**
 * @schema HttpProxySpecRoutesServicesCookieRewritePolicies
 */
export interface HttpProxySpecRoutesServicesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePolicies(obj: HttpProxySpecRoutesServicesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema HttpProxySpecRoutesServicesProtocol
 */
export enum HttpProxySpecRoutesServicesProtocol {
  /** h2 */
  H2 = "h2",
  /** h2c */
  H2C = "h2c",
  /** tls */
  TLS = "tls",
}

/**
 * The policy for managing request headers during proxying.
 *
 * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy
 */
export interface HttpProxySpecRoutesServicesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesServicesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesRequestHeadersPolicy(obj: HttpProxySpecRoutesServicesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesServicesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy
 */
export interface HttpProxySpecRoutesServicesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecRoutesServicesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesResponseHeadersPolicy(obj: HttpProxySpecRoutesServicesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecRoutesServicesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Slow start will gradually increase amount of traffic to a newly added endpoint.
 *
 * @schema HttpProxySpecRoutesServicesSlowStartPolicy
 */
export interface HttpProxySpecRoutesServicesSlowStartPolicy {
  /**
   * The speed of traffic increase over the slow start window. Defaults to 1.0, so that endpoint would get linearly increasing amount of traffic. When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly. The value of aggression parameter should be greater than 0.0.
   * More info: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start
   *
   * @default 1.0, so that endpoint would get linearly increasing amount of traffic. When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly. The value of aggression parameter should be greater than 0.0.
   * @schema HttpProxySpecRoutesServicesSlowStartPolicy#aggression
   */
  readonly aggression?: string;

  /**
   * The minimum or starting percentage of traffic to send to new endpoints. A non-zero value helps avoid a too small initial weight, which may cause endpoints in slow start mode to receive no traffic in the beginning of the slow start window. If not specified, the default is 10%.
   *
   * @schema HttpProxySpecRoutesServicesSlowStartPolicy#minWeightPercent
   */
  readonly minWeightPercent?: number;

  /**
   * The duration of slow start window. Duration is expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * @schema HttpProxySpecRoutesServicesSlowStartPolicy#window
   */
  readonly window: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesSlowStartPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesSlowStartPolicy(obj: HttpProxySpecRoutesServicesSlowStartPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'minWeightPercent': obj.minWeightPercent,
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema HttpProxySpecRoutesServicesValidation
 */
export interface HttpProxySpecRoutesServicesValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema HttpProxySpecRoutesServicesValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema HttpProxySpecRoutesServicesValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesValidation(obj: HttpProxySpecRoutesServicesValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHashPolicy contains configuration for an individual hash policy on a request attribute.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies {
  /**
   * HashSourceIP should be set to true when request source IP hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#hashSourceIP
   */
  readonly hashSourceIp?: boolean;

  /**
   * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#headerHashOptions
   */
  readonly headerHashOptions?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions;

  /**
   * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#queryParameterHashOptions
   */
  readonly queryParameterHashOptions?: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions;

  /**
   * Terminal is a flag that allows for short-circuiting computing of a hash for a given request. If set to true, and the request attribute specified in the attribute hash options is present, no further hash policies will be used to calculate a hash for the request.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies#terminal
   */
  readonly terminal?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hashSourceIP': obj.hashSourceIp,
    'headerHashOptions': toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj.headerHashOptions),
    'queryParameterHashOptions': toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj.queryParameterHashOptions),
    'terminal': obj.terminal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePolicies {
  /**
   * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#domainRewrite
   */
  readonly domainRewrite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite;

  /**
   * Name is the name of the cookie for which attributes will be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#name
   */
  readonly name: string;

  /**
   * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#pathRewrite
   */
  readonly pathRewrite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite;

  /**
   * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#sameSite
   */
  readonly sameSite?: HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite;

  /**
   * Secure enables rewriting the Set-Cookie Secure element. If not set, Secure attribute will not be rewritten.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePolicies#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePolicies(obj: HttpProxySpecTcpproxyServicesCookieRewritePolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainRewrite': toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite(obj.domainRewrite),
    'name': obj.name,
    'pathRewrite': toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite(obj.pathRewrite),
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocol may be used to specify (or override) the protocol used to reach this Service. Values may be tls, h2, h2c. If omitted, protocol-selection falls back on Service annotations.
 *
 * @schema HttpProxySpecTcpproxyServicesProtocol
 */
export enum HttpProxySpecTcpproxyServicesProtocol {
  /** h2 */
  H2 = "h2",
  /** h2c */
  H2C = "h2c",
  /** tls */
  TLS = "tls",
}

/**
 * The policy for managing request headers during proxying.
 *
 * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy
 */
export interface HttpProxySpecTcpproxyServicesRequestHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicy#set
   */
  readonly set?: HttpProxySpecTcpproxyServicesRequestHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesRequestHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicy(obj: HttpProxySpecTcpproxyServicesRequestHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The policy for managing response headers during proxying. Rewriting the 'Host' header is not supported.
 *
 * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy
 */
export interface HttpProxySpecTcpproxyServicesResponseHeadersPolicy {
  /**
   * Remove specifies a list of HTTP header names to remove.
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy#remove
   */
  readonly remove?: string[];

  /**
   * Set specifies a list of HTTP header values that will be set in the HTTP header. If the header does not exist it will be added, otherwise it will be overwritten with the new value.
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicy#set
   */
  readonly set?: HttpProxySpecTcpproxyServicesResponseHeadersPolicySet[];

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesResponseHeadersPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicy(obj: HttpProxySpecTcpproxyServicesResponseHeadersPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remove': obj.remove?.map(y => y),
    'set': obj.set?.map(y => toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicySet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Slow start will gradually increase amount of traffic to a newly added endpoint.
 *
 * @schema HttpProxySpecTcpproxyServicesSlowStartPolicy
 */
export interface HttpProxySpecTcpproxyServicesSlowStartPolicy {
  /**
   * The speed of traffic increase over the slow start window. Defaults to 1.0, so that endpoint would get linearly increasing amount of traffic. When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly. The value of aggression parameter should be greater than 0.0.
   * More info: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start
   *
   * @default 1.0, so that endpoint would get linearly increasing amount of traffic. When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly. The value of aggression parameter should be greater than 0.0.
   * @schema HttpProxySpecTcpproxyServicesSlowStartPolicy#aggression
   */
  readonly aggression?: string;

  /**
   * The minimum or starting percentage of traffic to send to new endpoints. A non-zero value helps avoid a too small initial weight, which may cause endpoints in slow start mode to receive no traffic in the beginning of the slow start window. If not specified, the default is 10%.
   *
   * @schema HttpProxySpecTcpproxyServicesSlowStartPolicy#minWeightPercent
   */
  readonly minWeightPercent?: number;

  /**
   * The duration of slow start window. Duration is expressed in the Go [Duration format](https://godoc.org/time#ParseDuration). Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   *
   * @schema HttpProxySpecTcpproxyServicesSlowStartPolicy#window
   */
  readonly window: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesSlowStartPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesSlowStartPolicy(obj: HttpProxySpecTcpproxyServicesSlowStartPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'minWeightPercent': obj.minWeightPercent,
    'window': obj.window,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamValidation defines how to verify the backend service's certificate
 *
 * @schema HttpProxySpecTcpproxyServicesValidation
 */
export interface HttpProxySpecTcpproxyServicesValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema HttpProxySpecTcpproxyServicesValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema HttpProxySpecTcpproxyServicesValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesValidation(obj: HttpProxySpecTcpproxyServicesValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AuthPolicy sets a default authorization policy for client requests. This policy will be used unless overridden by individual routes.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy
 */
export interface HttpProxySpecVirtualhostAuthorizationAuthPolicy {
  /**
   * Context is a set of key/value pairs that are sent to the authentication server in the check request. If a context is provided at an enclosing scope, the entries are merged such that the inner scope overrides matching keys from the outer scope.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy#context
   */
  readonly context?: { [key: string]: string };

  /**
   * When true, this field disables client request authentication for the scope of the policy.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationAuthPolicy#disabled
   */
  readonly disabled?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationAuthPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationAuthPolicy(obj: HttpProxySpecVirtualhostAuthorizationAuthPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': ((obj.context) === undefined) ? undefined : (Object.entries(obj.context).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'disabled': obj.disabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtensionServiceRef specifies the extension resource that will authorize client requests.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef
 */
export interface HttpProxySpecVirtualhostAuthorizationExtensionRef {
  /**
   * API version of the referent. If this field is not specified, the default "projectcontour.io/v1alpha1" will be used
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the referent. If this field is not specifies, the namespace of the resource that targets the referent will be used.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @schema HttpProxySpecVirtualhostAuthorizationExtensionRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationExtensionRef(obj: HttpProxySpecVirtualhostAuthorizationExtensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WithRequestBody specifies configuration for sending the client request's body to authorization server.
 *
 * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody
 */
export interface HttpProxySpecVirtualhostAuthorizationWithRequestBody {
  /**
   * If AllowPartialMessage is true, then Envoy will buffer the body until MaxRequestBytes are reached.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#allowPartialMessage
   */
  readonly allowPartialMessage?: boolean;

  /**
   * MaxRequestBytes sets the maximum size of message body ExtAuthz filter will hold in-memory.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#maxRequestBytes
   */
  readonly maxRequestBytes?: number;

  /**
   * If PackAsBytes is true, the body sent to Authorization Server is in raw bytes.
   *
   * @schema HttpProxySpecVirtualhostAuthorizationWithRequestBody#packAsBytes
   */
  readonly packAsBytes?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostAuthorizationWithRequestBody' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostAuthorizationWithRequestBody(obj: HttpProxySpecVirtualhostAuthorizationWithRequestBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPartialMessage': obj.allowPartialMessage,
    'maxRequestBytes': obj.maxRequestBytes,
    'packAsBytes': obj.packAsBytes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
 *
 * @schema HttpProxySpecVirtualhostIpAllowPolicySource
 */
export enum HttpProxySpecVirtualhostIpAllowPolicySource {
  /** Peer */
  PEER = "Peer",
  /** Remote */
  REMOTE = "Remote",
}

/**
 * Source indicates how to determine the ip address to filter on, and can be one of two values: - `Remote` filters on the ip address of the client, accounting for PROXY and X-Forwarded-For as needed. - `Peer` filters on the ip of the network request, ignoring PROXY and X-Forwarded-For.
 *
 * @schema HttpProxySpecVirtualhostIpDenyPolicySource
 */
export enum HttpProxySpecVirtualhostIpDenyPolicySource {
  /** Peer */
  PEER = "Peer",
  /** Remote */
  REMOTE = "Remote",
}

/**
 * Remote JWKS to use for verifying JWT signatures.
 *
 * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks
 */
export interface HttpProxySpecVirtualhostJwtProvidersRemoteJwks {
  /**
   * How long to cache the JWKS locally. If not specified, Envoy's default of 5m applies.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks#cacheDuration
   */
  readonly cacheDuration?: string;

  /**
   * The DNS IP address resolution policy for the JWKS URI. When configured as "v4", the DNS resolver will only perform a lookup for addresses in the IPv4 family. If "v6" is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If "all" is configured, the DNS resolver will perform a lookup for addresses in both the IPv4 and IPv6 family. If "auto" is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. If not specified, the Contour-wide setting defined in the config file or ContourConfiguration applies (defaults to "auto").
   * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks#dnsLookupFamily
   */
  readonly dnsLookupFamily?: HttpProxySpecVirtualhostJwtProvidersRemoteJwksDnsLookupFamily;

  /**
   * How long to wait for a response from the URI. If not specified, a default of 1s applies.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks#timeout
   */
  readonly timeout?: string;

  /**
   * The URI for the JWKS.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks#uri
   */
  readonly uri: string;

  /**
   * UpstreamValidation defines how to verify the JWKS's TLS certificate.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwks#validation
   */
  readonly validation?: HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostJwtProvidersRemoteJwks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostJwtProvidersRemoteJwks(obj: HttpProxySpecVirtualhostJwtProvidersRemoteJwks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cacheDuration': obj.cacheDuration,
    'dnsLookupFamily': obj.dnsLookupFamily,
    'timeout': obj.timeout,
    'uri': obj.uri,
    'validation': toJson_HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation(obj.validation),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global defines global rate limiting parameters, i.e. parameters defining descriptors that are sent to an external rate limit service (RLS) for a rate limit decision on each request.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobal
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobal {
  /**
   * Descriptors defines the list of descriptors that will be generated and sent to the rate limit service. Each descriptor contains 1+ key-value pair entries.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobal#descriptors
   */
  readonly descriptors?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors[];

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobal(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptors': obj.descriptors?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Local defines local rate limiting parameters, i.e. parameters for rate limiting that occurs within each Envoy pod as requests are handled.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyLocal {
  /**
   * Burst defines the number of requests above the requests per unit that should be allowed within a short period of time.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#burst
   */
  readonly burst?: number;

  /**
   * Requests defines how many requests per unit of time should be allowed before rate limiting occurs.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#requests
   */
  readonly requests: number;

  /**
   * ResponseHeadersToAdd is an optional list of response headers to set when a request is rate-limited.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#responseHeadersToAdd
   */
  readonly responseHeadersToAdd?: HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd[];

  /**
   * ResponseStatusCode is the HTTP status code to use for responses to rate-limited requests. Codes must be in the 400-599 range (inclusive). If not specified, the Envoy default of 429 (Too Many Requests) is used.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#responseStatusCode
   */
  readonly responseStatusCode?: number;

  /**
   * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocal#unit
   */
  readonly unit: HttpProxySpecVirtualhostRateLimitPolicyLocalUnit;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyLocal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyLocal(obj: HttpProxySpecVirtualhostRateLimitPolicyLocal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'requests': obj.requests,
    'responseHeadersToAdd': obj.responseHeadersToAdd?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd(y)),
    'responseStatusCode': obj.responseStatusCode,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClientValidation defines how to verify the client certificate when an external client establishes a TLS connection to Envoy.
 * This setting:
 * 1. Enables TLS client certificate validation. 2. Specifies how the client certificate will be validated (i.e. validation required or skipped).
 * Note: Setting client certificate validation to be skipped should be only used in conjunction with an external authorization server that performs client validation as Contour will ensure client certificates are passed along.
 *
 * @schema HttpProxySpecVirtualhostTlsClientValidation
 */
export interface HttpProxySpecVirtualhostTlsClientValidation {
  /**
   * Name of a Kubernetes secret that contains a CA certificate bundle. The secret must contain key named ca.crt. The client certificate must validate against the certificates in the bundle. If specified and SkipClientCertValidation is true, client certificates will be required on requests.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#caSecret
   */
  readonly caSecret?: string;

  /**
   * If this option is set to true, only the certificate at the end of the certificate chain will be subject to validation by CRL.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#crlOnlyVerifyLeafCert
   */
  readonly crlOnlyVerifyLeafCert?: boolean;

  /**
   * Name of a Kubernetes opaque secret that contains a concatenated list of PEM encoded CRLs. The secret must contain key named crl.pem. This field will be used to verify that a client certificate has not been revoked. CRLs must be available from all CAs, unless crlOnlyVerifyLeafCert is true. Large CRL lists are not supported since individual secrets are limited to 1MiB in size.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#crlSecret
   */
  readonly crlSecret?: string;

  /**
   * ForwardClientCertificate adds the selected data from the passed client TLS certificate to the x-forwarded-client-cert header.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidation#forwardClientCertificate
   */
  readonly forwardClientCertificate?: HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate;

  /**
   * OptionalClientCertificate when set to true will request a client certificate but allow the connection to continue if the client does not provide one. If a client certificate is sent, it will be verified according to the other properties, which includes disabling validation if SkipClientCertValidation is set. Defaults to false.
   *
   * @default false.
   * @schema HttpProxySpecVirtualhostTlsClientValidation#optionalClientCertificate
   */
  readonly optionalClientCertificate?: boolean;

  /**
   * SkipClientCertValidation disables downstream client certificate validation. Defaults to false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.
   *
   * @default false. This field is intended to be used in conjunction with external authorization in order to enable the external authorization server to validate client certificates. When this field is set to true, client certificates are requested but not verified by Envoy. If CACertificate is specified, client certificates are required on requests, but not verified. If external authorization is in use, they are presented to the external authorization server.
   * @schema HttpProxySpecVirtualhostTlsClientValidation#skipClientCertValidation
   */
  readonly skipClientCertValidation?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostTlsClientValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostTlsClientValidation(obj: HttpProxySpecVirtualhostTlsClientValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'crlOnlyVerifyLeafCert': obj.crlOnlyVerifyLeafCert,
    'crlSecret': obj.crlSecret,
    'forwardClientCertificate': toJson_HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate(obj.forwardClientCertificate),
    'optionalClientCertificate': obj.optionalClientCertificate,
    'skipClientCertValidation': obj.skipClientCertValidation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: HttpProxySpecRoutesLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptor defines a list of key-value pair generators.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors {
  /**
   * Entries is the list of key-value pair generators.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors#entries
   */
  readonly entries?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries[];

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entries': obj.entries?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd
 */
export interface HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd(obj: HttpProxySpecRoutesRateLimitPolicyLocalResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyLocalUnit
 */
export enum HttpProxySpecRoutesRateLimitPolicyLocalUnit {
  /** second */
  SECOND = "second",
  /** minute */
  MINUTE = "minute",
  /** hour */
  HOUR = "hour",
}

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecRoutesServicesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecRoutesServicesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecRoutesServicesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = "Strict",
  /** Lax */
  LAX = "Lax",
  /** None */
  NONE = "None",
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet
 */
export interface HttpProxySpecRoutesServicesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesServicesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesRequestHeadersPolicySet(obj: HttpProxySpecRoutesServicesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet
 */
export interface HttpProxySpecRoutesServicesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecRoutesServicesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesServicesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesServicesResponseHeadersPolicySet(obj: HttpProxySpecRoutesServicesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderHashOptions should be set when request header hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions {
  /**
   * HeaderName is the name of the HTTP request header that will be used to calculate the hash key. If the header specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesHeaderHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * QueryParameterHashOptions should be set when request query parameter hash based load balancing is desired. It must be the only hash option field set, otherwise this request hash policy object will be ignored.
 *
 * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions
 */
export interface HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions {
  /**
   * ParameterName is the name of the HTTP request query parameter that will be used to calculate the hash key. If the query parameter specified is not present on a request, no hash will be produced.
   *
   * @schema HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions#parameterName
   */
  readonly parameterName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions(obj: HttpProxySpecTcpproxyLoadBalancerPolicyRequestHashPoliciesQueryParameterHashOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'parameterName': obj.parameterName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainRewrite enables rewriting the Set-Cookie Domain element. If not set, Domain will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite {
  /**
   * Value is the value to rewrite the Domain attribute to. For now this is required.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite(obj: HttpProxySpecTcpproxyServicesCookieRewritePoliciesDomainRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PathRewrite enables rewriting the Set-Cookie Path element. If not set, Path will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite
 */
export interface HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite {
  /**
   * Value is the value to rewrite the Path attribute to. For now this is required.
   *
   * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite(obj: HttpProxySpecTcpproxyServicesCookieRewritePoliciesPathRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SameSite enables rewriting the Set-Cookie SameSite element. If not set, SameSite attribute will not be rewritten.
 *
 * @schema HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite
 */
export enum HttpProxySpecTcpproxyServicesCookieRewritePoliciesSameSite {
  /** Strict */
  STRICT = "Strict",
  /** Lax */
  LAX = "Lax",
  /** None */
  NONE = "None",
}

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet
 */
export interface HttpProxySpecTcpproxyServicesRequestHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecTcpproxyServicesRequestHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesRequestHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesRequestHeadersPolicySet(obj: HttpProxySpecTcpproxyServicesRequestHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet
 */
export interface HttpProxySpecTcpproxyServicesResponseHeadersPolicySet {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecTcpproxyServicesResponseHeadersPolicySet#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecTcpproxyServicesResponseHeadersPolicySet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecTcpproxyServicesResponseHeadersPolicySet(obj: HttpProxySpecTcpproxyServicesResponseHeadersPolicySet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The DNS IP address resolution policy for the JWKS URI. When configured as "v4", the DNS resolver will only perform a lookup for addresses in the IPv4 family. If "v6" is configured, the DNS resolver will only perform a lookup for addresses in the IPv6 family. If "all" is configured, the DNS resolver will perform a lookup for addresses in both the IPv4 and IPv6 family. If "auto" is configured, the DNS resolver will first perform a lookup for addresses in the IPv6 family and fallback to a lookup for addresses in the IPv4 family. If not specified, the Contour-wide setting defined in the config file or ContourConfiguration applies (defaults to "auto").
 * See https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html#envoy-v3-api-enum-config-cluster-v3-cluster-dnslookupfamily for more information.
 *
 * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwksDnsLookupFamily
 */
export enum HttpProxySpecVirtualhostJwtProvidersRemoteJwksDnsLookupFamily {
  /** auto */
  AUTO = "auto",
  /** v4 */
  V4 = "v4",
  /** v6 */
  V6 = "v6",
}

/**
 * UpstreamValidation defines how to verify the JWKS's TLS certificate.
 *
 * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation
 */
export interface HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation {
  /**
   * Name or namespaced name of the Kubernetes secret used to validate the certificate presented by the backend. The secret must contain key named ca.crt.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation#caSecret
   */
  readonly caSecret: string;

  /**
   * Key which is expected to be present in the 'subjectAltName' of the presented certificate.
   *
   * @schema HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation#subjectName
   */
  readonly subjectName: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation(obj: HttpProxySpecVirtualhostJwtProvidersRemoteJwksValidation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caSecret': obj.caSecret,
    'subjectName': obj.subjectName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptor defines a list of key-value pair generators.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors {
  /**
   * Entries is the list of key-value pair generators.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors#entries
   */
  readonly entries?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries[];

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entries': obj.entries?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderValue represents a header name/value pair
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd {
  /**
   * Name represents a key of a header
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd#name
   */
  readonly name: string;

  /**
   * Value represents the value of a header specified by a key
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd(obj: HttpProxySpecVirtualhostRateLimitPolicyLocalResponseHeadersToAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Unit defines the period of time within which requests over the limit will be rate limited. Valid values are "second", "minute" and "hour".
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyLocalUnit
 */
export enum HttpProxySpecVirtualhostRateLimitPolicyLocalUnit {
  /** second */
  SECOND = "second",
  /** minute */
  MINUTE = "minute",
  /** hour */
  HOUR = "hour",
}

/**
 * ForwardClientCertificate adds the selected data from the passed client TLS certificate to the x-forwarded-client-cert header.
 *
 * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate
 */
export interface HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate {
  /**
   * Client cert in URL encoded PEM format.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate#cert
   */
  readonly cert?: boolean;

  /**
   * Client cert chain (including the leaf cert) in URL encoded PEM format.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate#chain
   */
  readonly chain?: boolean;

  /**
   * DNS type Subject Alternative Names of the client cert.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate#dns
   */
  readonly dns?: boolean;

  /**
   * Subject of the client cert.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate#subject
   */
  readonly subject?: boolean;

  /**
   * URI type Subject Alternative Name of the client cert.
   *
   * @schema HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate#uri
   */
  readonly uri?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate(obj: HttpProxySpecVirtualhostTlsClientValidationForwardClientCertificate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'chain': obj.chain,
    'dns': obj.dns,
    'subject': obj.subject,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries {
  /**
   * GenericKey defines a descriptor entry with a static key and value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#genericKey
   */
  readonly genericKey?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey;

  /**
   * RemoteAddress defines a descriptor entry with a key of "remote_address" and a value equal to the client's IP address (from x-forwarded-for).
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#remoteAddress
   */
  readonly remoteAddress?: any;

  /**
   * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#requestHeader
   */
  readonly requestHeader?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader;

  /**
   * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries#requestHeaderValueMatch
   */
  readonly requestHeaderValueMatch?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'genericKey': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj.genericKey),
    'remoteAddress': obj.remoteAddress,
    'requestHeader': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj.requestHeader),
    'requestHeaderValueMatch': toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj.requestHeaderValueMatch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimitDescriptorEntry is a key-value pair generator. Exactly one field on this struct must be non-nil.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries {
  /**
   * GenericKey defines a descriptor entry with a static key and value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#genericKey
   */
  readonly genericKey?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey;

  /**
   * RemoteAddress defines a descriptor entry with a key of "remote_address" and a value equal to the client's IP address (from x-forwarded-for).
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#remoteAddress
   */
  readonly remoteAddress?: any;

  /**
   * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#requestHeader
   */
  readonly requestHeader?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader;

  /**
   * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries#requestHeaderValueMatch
   */
  readonly requestHeaderValueMatch?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'genericKey': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj.genericKey),
    'remoteAddress': obj.remoteAddress,
    'requestHeader': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj.requestHeader),
    'requestHeaderValueMatch': toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj.requestHeaderValueMatch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GenericKey defines a descriptor entry with a static key and value.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
  /**
   * Key defines the key of the descriptor entry. If not set, the key is set to "generic_key".
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey#key
   */
  readonly key?: string;

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesGenericKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
  /**
   * DescriptorKey defines the key to use on the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#descriptorKey
   */
  readonly descriptorKey?: string;

  /**
   * HeaderName defines the name of the header to look for on the request.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptorKey': obj.descriptorKey,
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
  /**
   * ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#expectMatch
   */
  readonly expectMatch?: boolean;

  /**
   * Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#headers
   */
  readonly headers?: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders[];

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectMatch': obj.expectMatch,
    'headers': obj.headers?.map(y => toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GenericKey defines a descriptor entry with a static key and value.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey {
  /**
   * Key defines the key of the descriptor entry. If not set, the key is set to "generic_key".
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey#key
   */
  readonly key?: string;

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesGenericKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeader defines a descriptor entry that's populated only if a given header is present on the request. The descriptor key is static, and the descriptor value is equal to the value of the header.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader {
  /**
   * DescriptorKey defines the key to use on the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#descriptorKey
   */
  readonly descriptorKey?: string;

  /**
   * HeaderName defines the name of the header to look for on the request.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader#headerName
   */
  readonly headerName?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'descriptorKey': obj.descriptorKey,
    'headerName': obj.headerName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RequestHeaderValueMatch defines a descriptor entry that's populated if the request's headers match a set of 1+ match criteria. The descriptor key is "header_match", and the descriptor value is static.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch {
  /**
   * ExpectMatch defines whether the request must positively match the match criteria in order to generate a descriptor entry (i.e. true), or not match the match criteria in order to generate a descriptor entry (i.e. false). The default is true.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#expectMatch
   */
  readonly expectMatch?: boolean;

  /**
   * Headers is a list of 1+ match criteria to apply against the request to determine whether to populate the descriptor entry or not.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#headers
   */
  readonly headers?: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders[];

  /**
   * Value defines the value of the descriptor entry.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expectMatch': obj.expectMatch,
    'headers': obj.headers?.map(y => toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(y)),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.
 *
 * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders
 */
export interface HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(obj: HttpProxySpecRoutesRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HeaderMatchCondition specifies how to conditionally match against HTTP headers. The Name field is required, but only one of the remaining fields should be be provided.
 *
 * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders
 */
export interface HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders {
  /**
   * Contains specifies a substring that must be present in the header value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#contains
   */
  readonly contains?: string;

  /**
   * Exact specifies a string that the header value must be equal to.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * Name is the name of the header to match against. Name is required. Header names are case insensitive.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#name
   */
  readonly name: string;

  /**
   * NotContains specifies a substring that must not be present in the header value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notcontains
   */
  readonly notcontains?: string;

  /**
   * NoExact specifies a string that the header value must not be equal to. The condition is true if the header has any other value.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notexact
   */
  readonly notexact?: string;

  /**
   * NotPresent specifies that condition is true when the named header is not present. Note that setting NotPresent to false does not make the condition true if the named header is present.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#notpresent
   */
  readonly notpresent?: boolean;

  /**
   * Present specifies that condition is true when the named header is present, regardless of its value. Note that setting Present to false does not make the condition true if the named header is absent.
   *
   * @schema HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders#present
   */
  readonly present?: boolean;

}

/**
 * Converts an object of type 'HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders(obj: HttpProxySpecVirtualhostRateLimitPolicyGlobalDescriptorsEntriesRequestHeaderValueMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contains': obj.contains,
    'exact': obj.exact,
    'name': obj.name,
    'notcontains': obj.notcontains,
    'notexact': obj.notexact,
    'notpresent': obj.notpresent,
    'present': obj.present,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.
 *
 * @schema TLSCertificateDelegation
 */
export class TlsCertificateDelegation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TLSCertificateDelegation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'projectcontour.io/v1',
    kind: 'TLSCertificateDelegation',
  }

  /**
   * Renders a Kubernetes manifest for "TLSCertificateDelegation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TlsCertificateDelegationProps): any {
    return {
      ...TlsCertificateDelegation.GVK,
      ...toJson_TlsCertificateDelegationProps(props),
    };
  }

  /**
   * Defines a "TLSCertificateDelegation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TlsCertificateDelegationProps) {
    super(scope, id, {
      ...TlsCertificateDelegation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TlsCertificateDelegation.GVK,
      ...toJson_TlsCertificateDelegationProps(resolved),
    };
  }
}

/**
 * TLSCertificateDelegation is an TLS Certificate Delegation CRD specification. See design/tls-certificate-delegation.md for details.
 *
 * @schema TLSCertificateDelegation
 */
export interface TlsCertificateDelegationProps {
  /**
   * @schema TLSCertificateDelegation#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * TLSCertificateDelegationSpec defines the spec of the CRD
   *
   * @schema TLSCertificateDelegation#spec
   */
  readonly spec: TlsCertificateDelegationSpec;

}

/**
 * Converts an object of type 'TlsCertificateDelegationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationProps(obj: TlsCertificateDelegationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TlsCertificateDelegationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSCertificateDelegationSpec defines the spec of the CRD
 *
 * @schema TlsCertificateDelegationSpec
 */
export interface TlsCertificateDelegationSpec {
  /**
   * @schema TlsCertificateDelegationSpec#delegations
   */
  readonly delegations: TlsCertificateDelegationSpecDelegations[];

}

/**
 * Converts an object of type 'TlsCertificateDelegationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationSpec(obj: TlsCertificateDelegationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delegations': obj.delegations?.map(y => toJson_TlsCertificateDelegationSpecDelegations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateDelegation maps the authority to reference a secret in the current namespace to a set of namespaces.
 *
 * @schema TlsCertificateDelegationSpecDelegations
 */
export interface TlsCertificateDelegationSpecDelegations {
  /**
   * required, the name of a secret in the current namespace.
   *
   * @schema TlsCertificateDelegationSpecDelegations#secretName
   */
  readonly secretName: string;

  /**
   * required, the namespaces the authority to reference the secret will be delegated to. If TargetNamespaces is nil or empty, the CertificateDelegation' is ignored. If the TargetNamespace list contains the character, "*" the secret will be delegated to all namespaces.
   *
   * @schema TlsCertificateDelegationSpecDelegations#targetNamespaces
   */
  readonly targetNamespaces: string[];

}

/**
 * Converts an object of type 'TlsCertificateDelegationSpecDelegations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TlsCertificateDelegationSpecDelegations(obj: TlsCertificateDelegationSpecDelegations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretName': obj.secretName,
    'targetNamespaces': obj.targetNamespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

